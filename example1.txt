МИНИСТЕРСТВО ОБРАЗОВАНИЯ И НАУКИ КЫРГЫЗСКОЙ РЕСПУБЛИКИ
КЫРГЫЗСКИЙ ГОСУДАРСТВЕННЫЙ ТЕХНИЧЕСКИЙ УНИВЕРСИТЕТ
имени И. Раззакова
Кафедра «ПРОГРАММНОЕ ОБЕСПЕЧЕНИЕ КОМПЬЮТЕРНЫХ СИСТЕМ»




ВЫПУСКНАЯ КВАЛИФИКАЦИОННАЯ РАБОТА

по теме
“РАЗРАБОТКА СИСТЕМЫ ЗАКАЗА МЕДИКАМЕНТОВ И ИЗДЕЛИЙ МЕДИЦИНСКОГО НАЗНАЧЕНИЯ ДЛЯ АПТЕЧНОГО СКЛАДА”

на академическую степень бакалавра
по направлению: 710400 Программная инженерия



Выполнил                                  Студент группы ПИ(б)-1–18
                                                     Жарков Александр Евгеньевич
Руководитель                            Мусина Индира Рафиковна



Бишкек 2022

КЫРГЫЗ РЕСПУБЛИКАСЫНЫН БИЛИМ БЕРҮҮ ЖАНА ИЛИМ МИНИСТРЛИГИ
И. РАЗЗАКОВ атындагы
КЫРГЫЗ МАМЛЕКЕТТИК ТЕХНИКАЛЫК УНИВЕРСИТЕТИ
«КОМПЬЮТЕРДИК СИСТЕМАЛАРДЫ ПРОГРАММАЛЫК КАМСЫЗДОО» кафедрасы



БҮТҮРҮҮЧҮЛӨРДҮН КВАЛИФИКАЦИЯЛЫК
ИШТЕРИНИН ЖЫЙЫНТЫГЫ
“Дарыкана кампасы үчүн дары-дармектерди жана медициналык буюмдарды заказ кылуу системасын иштеп чыгуу”

академиялык бакалавр даражасы
710400 «Программдык инженерия» багыты боюнча


Аткарган                                    ПИ(б)-1–18 тайпасынын студентти
                                                     Жарков Александр Евгеньевич
Жетекчи                                     Мусина Индира Рафиковна



Бишкек 2022
Аннотация
В данной пояснительной записке представлены результаты разработки системы заказа медикаментов и изделий медицинского назначения для аптечного склада.
Предметом исследования является прогнозирование спроса на лекарственные средства для аптечного склада.
Пояснительная записка содержит 9 глав: введение, анализ и разработка требований, конструкторские работы, разработка документации, экспериментальный раздел, заключение, глоссарий, список используемых источников и три приложения.
Во введении описана актуальность работы, определены цели и задачи разработки.
В главе «Анализ и разработка требований» представлен анализ предметной области, обзор преимуществ и недостатков существующих аналогов. Определены основные требования к создаваемому программному продукту.
В главе «Конструкторские работы» представлены результаты проектирования с использованием диаграмм UML автоматизированной системы прогнозирования спроса на ЛС. При помощи диаграммы IDEF0 выполнен анализ существующей бизнес-модели аптечного склада, и предложен альтернативный вариант с использованием разрабатываемой системы. Приведено обоснование выбора средств реализации и архитектуры разрабатываемого ПО. 
В главе «Разработка документации» приведены указания и пояснения к использованию ПО конечными пользователями и разработчиками ПО.
В главе «Экспериментальный раздел» показан план тестирования, среда тестирования и результаты выполнения разработанных тестов.
В главе «Заключение» подведены итоги данной работы: ее особенности и результаты, которые были достигнуты в ходе ее написания.
В состав работы также входят глоссарий с описанием терминов и приложения с описанием таблиц базы данных и листингом программы.
Пояснительная записка состоит из 91 страницы, содержит 69 рисунков, 31 таблицу, 17 формул, используется 10 источников.

Аннотация
Бул түшүндүрмө кат дары-дармек каражаттарынын ар бир түрүнө суроо-талаптын математикалык күтүүсүн болжолдоого мүмкүндүк берүүчү бирдиктүү дарыкана кампасы үчүн дары-дармек каражаттарына жана медициналык буюмдарга буйрутма берүү системасын иштеп чыгуунун натыйжаларын берет. 
Изилдөөнүн предмети дары-дармектерге болгон суроо-талапты болжолдоо болуп саналат.
Түшүндүрмө кат 9 бөлүмдү камтыйт: киришүү, талдоо жана талаптарды иштеп чыгуу, долбоорлоо иштери, документтерди иштеп чыгуу, эксперименталдык бөлүм, корутунду, глоссарий жана эки тиркеме.
«Кириш сөз» иштин актуалдуулугун баяндалат, иштеп чыгуунун максаттарын жана милдеттерин аныктайт.
«Талаптарды талдоо жана иштеп чыгуу» бөлүмүндө предметтик чөйрөгө талдоо жасалган, колдонуудагы аналогдордун артыкчылыктары жана кемчиликтери боюнча сереп жасалган. Түзүлгөн программалык продуктунун негизги касиеттери жана талаптары аныкталат.
«Дизайн иши» бөлүмүндө каралып жаткан системаны долбоорлоо UML диаграммалары аркылуу ишке ашырылган. IDEF0 контексттик диаграммасын колдонуу менен аптека кампасынын учурдагы бизнес моделине талдоо жүргүзүлүп, иштелип чыккан системаны колдонуу менен альтернативалуу вариант сунушталган. 
«Документтерди иштеп чыгуу»  бөлүмү акыркы колдонуучулар жана программалык камсыздоону иштеп чыгуучулар тарабынан программалык камсыздоону колдонуу боюнча көрсөтмөлөрдү жана түшүндүрмөлөрдү камтыйт.
«Эксперименталдык бөлүм»  бөлүмүндө тесттин планы, сыноо чөйрөсү жана тестти аткаруунун натыйжалары көрсөтүлөт.
Корутунду бөлүмүндө бул иштин жыйынтыгы чыгарылат: анын өзгөчөлүктөрү жана аны жазуу учурунда жетишилген натыйжалар.
Иште ошондой эле терминдердин жана колдонмолордун сыпаттамасы бар глоссарий, маалымат базасынын таблицаларынын сыпаттамасы, программанын листинги камтылган.
Түшүндүрмө кат 91 барактан турат, 69 сүрөт, 31 таблицадан турат, 17 формула,  10 булак колдонулган.
Содержание

Введение	15
Актуальность работы	15
Цели работы	16
Назначение разработки	16
ГЛАВА 1. АНАЛИЗ И РАЗРАБОТКА ТРЕБОВАНИЙ	17
1.1 Обоснование необходимости разработки	17
1.2 Функциональные требования к программе	17
1.3 Нефункциональные требования к программе	18
1.3.1. Требования к данным	18
1.3.2. Ограничения	18
1.3.3. Требования к интерфейсу	19
1.3.4. Требования к архитектуре	19
1.3.5. Безопасность	19
1.3.6. Требования к информационной и программной совместимости	20
1.3.7. Требования к надёжности	21
1.3.8. Требования к скорости работы программы (Performance)	21
1.3.9. Языки	21
1.3.10. Требования к программной документации	21
1.4 Обзор аналогов	22
1.4.1. Система управления запасами SIMPLE	22
1.4.2. Система прогнозирования STATISTICA	23
ГЛАВА 2. КОНСТРУКТОРСКИЕ РАБОТЫ	26
2.1 Диаграмма бизнес-процессов (IDEF0) AS-IS	26
2.1.1. Диаграмма бизнес-процессов (IDEF0) AS-IS первого уровня	26
2.1.2. Диаграмма бизнес-процессов (IDEF0) AS-IS второго уровня	28
2.2 Диаграмма бизнес-процессов (IDEF0) TO-BE	29
2.2.1. Диаграмма бизнес-процессов (IDEF0) TO-BE первого уровня	29
2.2.2. Диаграмма бизнес-процессов (IDEF0) TO-BE второго уровня	30
2.3 Используемые методы и алгоритмы	31
2.3.1. Формирование заказа на ЛС	31
2.3.2. Прогнозирование математического ожидания величины спроса на ЛС	34
2.4 Диаграмма прецендентов	35
2.5 Алгоритмическое проектирование. Диаграмма деятельности	37
2.5.1. Диаграмма деятельности для авторизации пользователей	37
2.5.2. Диаграмма деятельности менеджера с системой	38
2.5.3. Диаграмма деятельности для создания рекомендации	39
2.5.4. Диаграмма деятельности для простого экспоненциального сглаживания	40
2.5.5. Диаграмма деятельности для двойного сглаживания Брауна	41
2.6 Организация структуры базы данных	42
2.7 Диаграмма классов	43
2.8 Диаграмма последовательности	44
2.9 Диаграмма компонентов	45
2.10 Диаграмма развертывания	46
2.11 Выбор средств реализации	46
ГЛАВА 3. РАЗРАБОТКА ДОКУМЕНТАЦИИ	48
3.1 Требования к программному и аппаратному обеспечению	48
3.2 Руководство программиста	49
3.2.1. Репозиторий	49
3.2.2. История разработки	50
3.2.3. База данных	51
3.2.4. Структура проекта клиентской части	53
3.2.5. Структура проекта серверной части	55
3.3 Руководство пользователя	57
3.3.1. Форма входа	57
3.3.2. Главная страница в админ-панели	58
3.3.3. Страница ЛС в админ-панели	60
3.3.4. Страница категорий ЛС в админ-панели	64
3.3.5. Страница ЛС на складе в админ-панели	65
3.3.6. Страница продаж ЛС в админ-панели	67
3.3.7. Страница административных расходов в админ-панели	69
3.3.8. Страница сотрудников в админ-панели	70
3.3.9. Страница рекомендаций в админ-панели	72
ГЛАВА 4. ЭКСПЕРИМЕНТАЛЬНЫЙ РАЗДЕЛ	73
4.1 План тестирования.	73
4.1.1. Введение	73
4.1.2. Область тестирования	73
4.1.3. Стратегии тестирования	74
4.1.4. Методы тестирования	74
4.2 Среда тестирования.	75
4.3 Сценарии тестирования.	75
4.3.1. Юнит тестирование	76
4.3.2. Usability тестирование интерфейса клиентской части приложения	78
4.3.3. Интеграционное тестирование клиентской части приложения	80
4.3.4. Тестирование REST API	81
4.3.5. Метрики качества кода	86
4.4 Результаты тестирования	87
ЗАКЛЮЧЕНИЕ	88
ЛИТЕРАТУРА	89
ГЛОССАРИЙ	90
ПРИЛОЖЕНИЕ I	92
ПРИЛОЖЕНИЕ II	96
ПРИЛОЖЕНИЕ III	101


Введение
Развитие рыночных отношений ставит экономические субъекты в жесткие условия конкурентной борьбы, что требует от них высококачественного управления всеми процессами и грамотного распоряжения финансовыми и материальными ресурсами. Владея эффективными способами выработки, принятия и реализации управленческих решений, руководитель может обеспечить устойчивое развитие и конкурентоспособность предприятия в сложной экономической обстановке.
Для того, чтобы формализовать задачу принятия управленческого решения, проблема пополнения запасов в пределах данной ВКР будет рассматриваться на примере аптечного склада.
Актуальность работы
Аптеки зачастую оперируют тысячами единиц номенклатуры, имеют сложную структуру складов [1]. Спрос не стационарный, заранее не известен и зависит от множества параметров. Отдел управления запасами осуществляет определение текущей потребности аптеки в необходимых ЛС (лекарственных средств) и изделиях медицинского назначения, своевременную подачу заказов - требований на аптечные склады [2] и другие базы снабжения, прием и хранение поступающих медикаментов, а также их отпуск. Предъявляемый извне спрос должен удовлетворяться за счет наличия на складе запасов лекарственных средств.
Склад аптеки должен регулярно пополняться (из месяца в месяц). При этом надо учитывать, что при заказе аптекой большой партии ЛС, приобретение происходит по более выгодной цене (чем больше приобретаемый объем, тем меньше стоимость). Однако возрастают издержки за счет хранения лекарственных препаратов на складе. Кроме этого, возрастает риск превышения сроков хранения препаратов и соответственно повторного пополнения запасов. 
Анализ бизнес-модели аптеки показал, что менеджер фирмы накапливает информацию о текущем состоянии склада по проданным ЛС. Чтобы не понести убытков в связи с неожиданным спросом на продукцию, менеджер для каждого вида ЛС установил точку заказа – фиксированный уровень их запаса, при достижении которого необходимо сформировать следующий заказ на поставку. Этот уровень запаса менеджер устанавливает исходя из своего опыта и примерного состояния конъюнктуры рынка товаров. Подобный подход к принятию решения о пополнении склада содержит в себе большую долю риска, так как менеджер может принять интуитивно неверное решение и предприятие понесет убытки или не получит возможную прибыль.
Цели работы
Целью данной ВКР является построение компьютерной системы для оптимизации затрат в системе управления аптечного склада на основе разработки алгоритмов, позволяющих менеджеру принимать математически и экономически обоснованные решения по управлению аптечного пункта в условиях неопределенности.
Бизнес-целями разработки ПО являются:
    • Уменьшение затрат на закупку и хранение ЛС;
    • Уменьшение расходов, связанных с истечением срока годности хранимых ЛС;
    • Увеличение прибыли аптечного склада.
Назначение разработки
Назначением программы является:
    • Предоставление менеджеру рекомендаций, благодаря которым он сможет принимать математически и экономически обоснованные решения по формированию заказа на ЛС;
    • Хранение данных о зарегистрированных ЛС, количестве дефицитных ЛС, сотрудниках;
    • Прогнозирование спроса;
    • Предоставление возможности для сравнительного анализа спроса на ЛС за выбранные промежутки времени.

ГЛАВА 1. АНАЛИЗ И РАЗРАБОТКА ТРЕБОВАНИЙ
1.1 Обоснование необходимости разработки
Вышеописанные проблемы возможно решить, разработав альтернативную модель организации деятельности аптеки с использованием следующих модулей:
    1. Модуль учета, который накапливает данные по продажам ЛС за прошедшие периоды времени.
    2. Модуль прогнозирования, который позволяет предсказать спрос на каждый вид ЛС.
    3. Система поддержки принятия решения выдает рекомендацию по формированию склада (пополнению склада) с минимальными рисками потерь.
Новая модель будет способствовать менеджеру в принятии математически и экономически обоснованного решения по эффективному управлению аптекой.
1.2 Функциональные требования к программе
Программа должна предоставлять следующие функциональные возможности:
    • Аутентификация пользователей;
    • Авторизация с ролями “Админ” и “Менеджер”;
    • Создание, вывод, обновление, удаление данных о пользователях;
    • Создание, вывод, обновление, удаление данных о категориях ЛС, поступающих на склад;
    • Создание, вывод, обновление, удаление данных о ЛС на складе;
    • Формирование плана закупки ЛС на склад;
    • Оповещение пользователя по ЛС со сроком годности меньшим, чем две недели;
    • Сохранение истории продаж ЛС;
    • Прогнозирование величины спроса ЛС на следующий месяц. 
    • Формирование рекомендации о закупках ЛС с минимальными рисками потерь и максимальной прибылью.
    • Хранение истории рекомендаций;
    • Формирование отчетов по проданным и закупленным ЛС на складе;
    • Просмотр отчетов по ЛС на складе;
    • Графическое отображение величин спроса за выбранные промежутки времени.
1.3 Нефункциональные требования к программе
1.3.1. Требования к данным
Входные данными для системы являются:
    • Товар от поставщика (наименование, цена, количество);
    • Сопроводительные документы на ЛС;
    • Продажи;
    • Оплата за проданные ЛС;
    • Списанные ЛС;
    • Персональные данные сотрудников.
Хранимыми данными для системы являются:
    • Зарегистрированные ЛС;
    • Персональные и аутентификационные данные сотрудников;
    • Прогноз спроса;
    • Количество дефицитных ЛС на складе.
Выходные данными для системы являются:
    • Отчеты по прогнозам, ЛС, спросу;
    • Заявка на поставку ЛС
Все данные хранятся в БД.
1.3.2. Ограничения
Программа имеет следующие ограничения:
    • Программа рассчитывает прогноз математического ожидания спроса с использованием методов прогнозирования временных рядов (машинное обучение и нейронные сети не используются).
    • Программа рассчитывает прогноз спроса для временного промежутка, равного одному месяцу.
    • Frontend-приложение не поддерживает работу через браузер Internet Explorer любой версии.
1.3.3. Требования к интерфейсу
Интерфейс должен соответствовать следующим требованиям:
    • Интерфейс пользователя должен сохранять одинаковый стиль, то есть иметь одинаковую цветовую палитру, виджеты во всей программе. 
    • Цветовая схема интерфейса преимущественно должна состоять из зеленого, голубого, белого цвета и их оттенков, поскольку они не вызывают раздражения и усталости у пользователей.
    • Интерфейс должен быть интуитивно понятным пользователю. Например, кнопка удаления должна быть представлена в виде корзины красного цвета, поскольку красный цвет ассоциируется с опасностью, а корзина ассоциируется с невостребованными предметами.
    • Интерфейс должен содержать кнопки и текстовые поля со средних размеров.
    • Интерфейс должен содержать графики для наглядного демонстрирования расчетов программы, динамики прогнозов.
1.3.4. Требования к архитектуре
Архитектура системы состоит из:
    • База данных (БД) – это уже реализованная программа, которая производит долгосрочное хранение данных;
    • Backend, она же серверная часть – это часть программы, которая взаимодействует с БД, управляет основной бизнес-логикой приложения.
    • Frontend, она же клиентская часть – это часть программы, которую использует конечный пользователь. В роли это программы выступает сайт в браузере.
1.3.5. Безопасность 
Программа должна соответствовать следующим требования безопасности:
    • Обмен данными между backend и frontend частями приложения должен производиться через защищенный протокол HTTPS.
    • Авторизационные данные (токены, логины, пароли) в frontend части приложения должны храниться в local storage, а не в cookies, во избежание XSRF атаки.
    • Frontend и backend части приложения должны производить санитайзинг, то есть очищать входные данные от JavaScript [3] и SQL кода, во избежание XSS атак и SQL инъекций.
    • База данных должна быть защищена от несанкционированного доступа;
    • БД должна производить backup копии во избежание потери данных.
1.3.6. Требования к информационной и программной совместимости
Серверная часть:
    • Процессор: как минимум частотой 1 ГГц или SoC (System on a Chip, т.е. однокристальные системы) или выше;
    • Оперативная память: 4 ГБ (для 32-разрядных систем) или 8 ГБ (для 64-разрядных систем);
    • Дисковое пространство: 2 GB;
    • Операционная Windows, Linux, Mac OS;
    • СУБД Mongo DB;
    • JavaScript (стандарт EcmaScript6+);
    • Возможность доступа к localhost по HTTP протоколу.
    • Node.js 14+
Клиентская часть для ПК:
    • ОС: MS Windows 8/10, Mac OS X+, Ubuntu 16.04+;
    • Браузеры с поддержкой JavaScript’а (Chrome, Mozilla, Opera, Microsoft Edge и др.).
Клиентская часть для мобильных устройств:
    • OC: Android 6+, iOS 9+;
    • Браузеры для мобильных устройств с поддержкой JavaScript (Safari для iOS 9+, Chrome, Firefox).

1.3.7. Требования к надёжности
Система должна сохранять работоспособность и обеспечивать восстановление своих функций при возникновении следующих внештатных ситуаций:
    • При сбоях в системе электроснабжения аппаратной части, приводящих к перезагрузке ОС, восстановление программы должно происходить после перезапуска ОС и запуска исполняемого файла системы;
    • При ошибках в работе аппаратных средств (кроме носителей данных и программ) восстановление функции системы возлагается на ОС;
    • При ошибках, связанных с программным обеспечением (ОС и драйверы устройств), восстановление работоспособности возлагается на ОС.
1.3.8. Требования к скорости работы программы (Performance)
Программа должна соответствовать требования по скорости работы:
    • Среднее время реагирования программы на действия пользователя должно занимать 0.5–2 секунды, в противном случае у пользователя сложится впечатление, что программы неисправна.
    • Операция по расчету прогноза спроса должна занимать 1–10 секунд;
    • Программа должна отображать индикатор прогресса в процессе выполнения время затратных операциях, таких как:
            ▪ Построение графиков;
            ▪ Расчет прогноза спроса.
1.3.9. Языки
Интерфейс программы должен быть представлен на русском языке.
1.3.10. Требования к программной документации
Основными документами, регламентирующими разработку будущих программ, должны быть документы Единой системы программной документации (ЕСПД): руководство пользователя, руководство администратора, описание применения.

1.4 Обзор аналогов
Для лучшего понимания актуальности разработки ПО рассмотрим 2 программных продукта: систему управления запасами «SIMPLE» [4] и систему прогнозирования «STATISTICА» [5].
1.4.1. Система управления запасами SIMPLE
SIMPLE является автоматизированной системой управления.
Она обеспечивает сокращение товарных запасов при сокращении дефицита и
затрат по подвозке товара от поставщиков путем автоматической выдачи
оптимальных заявок на поставку. Программа состоит из блока
прогнозирования спроса, блока нормирования запасов, блока оперативного
управления запасами, блока оценки эффективности управления запасами. На рисунках 1.1–1.2 приведены пользовательские формы программы SIMPLE.

Рис. 1.1. Система SIMPLE. Раздел «Справочники».

Рис. 1.2. Система SIMPLE. Раздел «ABC-анализ».
Достоинства и недостатки данной системы представлены в таблице 1.1.
Таблица 1.1 – Достоинства и недостатки системы SIMPLE
Достоинства
Недостатки
Универсальная, может применяться на всех предприятиях, осуществляющих преимущественно складскую форму реализации 
Устаревший интерфейс
Основное внимание на наиболее существенном объекте – товарных запасах
Нет возможности распределённого доступа к системе
Выработка готовых ответов на вопросы управления запасами: что, в какой момент, в каком количестве заказывать
Данные хранятся на одном физическом ПК
Использование математико-статистических, аналитических методов в области теории управления запасам
Отсутствие подсистемы накопления данных, на основании которых
работают остальные функции системы

Сведения о поставщиках, материалах и движениях товаров подаются в программу в виде текстовых файлов

Наличие конвертера BEST для выгрузки данных из программ 1C
предполагает использование 1C, что существенно повышает стоимость
данной программы

1.4.2. Система прогнозирования STATISTICA
Программное обеспечение STATISTICA представляет собой комплект
инструментов всестороннего статистического анализа, менеджмента, добычи
и реализации данных. Программа вычисляет практически все используемые описательные статистики общего характера: медиану, моду, квартили, заданные пользователем перцентили, среднее значение и стандартное отклонение, доверительные интервалы для среднего, асимметрию и эксцесс (и их стандартные ошибки), гармоническое и геометрическое среднее, а также многие специальные описательные статистики. На рисунках 1.3 -1.4 приведены интерфейсы программы STATISTICA.

Рис. 1.3. Таблица исходных данных STATISTICA.

Рис. 1.4. Рабочая книга STATISTICA.
Достоинства и недостатки данной системы представлены в таблице 1.2.
Таблица 1.2 – Достоинства и недостатки системы STATISTICA
Достоинства
Недостатки
Доступны разнообразные графики и
диаграммы, в том числе и различные виды диаграмм размаха и гистограмм, гистограммы двумерных распределений, двух- и трехмерные диаграммы
рассеяния с помеченными подмножествами данных
Устаревший интерфейс
Можно проанализировать чрезвычайно большие
планы (более 500 переменных).
Нет возможности распределённого доступа к системе
Имеет специальные модули общего
нелинейного оценивания, с помощью которых можно оценить практически
любую определенную пользователем нелинейную модель
Данные хранятся на одном физическом ПК

Реализует множество функций, в большей части
избыточных, и поэтому является невостребованной и дорогостоящей для предприятий малого и среднего бизнеса, которые составляют большинство в
республике
Таким образом, вопрос о разработке ПО, которое позволяло бы принимать оптимальные решения по формированию заказа на товары, используя преимущества современных технологий, остается актуальным для рынка малого и среднего бизнеса Кыргызстана, несмотря на наличие уже разработанных аналогов.

ГЛАВА 2. КОНСТРУКТОРСКИЕ РАБОТЫ
2.1 Диаграмма бизнес-процессов (IDEF0) AS-IS
2.1.1. Диаграмма бизнес-процессов (IDEF0) AS-IS первого уровня
С целью выявления источника причин, приводящих к потерям для подобного типа предприятий, и нахождения способа их исправления был изучен процесс организации работы аптеки. Для этого разработана функциональная модель существующего процесса управления (AS-IS модель).
Моделирование бизнес-процессов позволяет проанализировать всесторонне не только, как предприятие работает в целом, но и как оно взаимодействует с поставщиками и заказчиками, как организована его деятельность на каждом отдельном участке работ. 
На рис. 2.1 показана контекстная диаграмма IDEF0 модели анализа бизнес-процессов AS-IS («как есть»).

Рис. 2.1. Модель AS-IS в виде контекстной диаграммы «Деятельность аптеки».
Для предприятия входными потоками являются:
    • Товар от поставщика - лекарственные препараты, получаемые от поставщиков;
    • Сопроводительные документы на ЛС - необходимая сопроводительная документация на лекарственные средства, получаемая от поставщика;
    • Продажи - реализованное количество лекарственных средств;
    • Оплата за проданные ЛС - деньги, вырученные за товар при его продаже.
    • Списанные ЛС – лекарственные средства, у которых истек срок годности и которые не подлежат продаже.
Выходными потоками являются:
    • Отчеты по прогнозу – статистика прогнозов;
    • Отчет по спросу – статистика спроса;
    • Отчет по ЛС – статистика продаж ЛС;
    • Заявка на поставку ЛС - заявка, содержащая полную информацию о заказываемых поставщику лекарственных средствах и объемах заказов;
    • Оплата за ЛС - деньги, оплачиваемые поставщику за лекарственные средства.
Управляющие потоки:
    • Нормативы заполнения склада - нормы, ограничивающие использование складских площадей, и правила использования складских помещений;
    • Должностные инструкции - различные правила и процедуры, которыми руководствуется сотрудники предприятия в процессе работы;
    • Сроки хранения — сроки хранения лекарственных средств на складе до истечения срока годности препарата;
    • Точка заказа - объемы заказов лекарственных средств, которые всегда должны быть на складе (определяются исходя из опыта менеджера); если запасы какого-либо препарата меньше точки заказа, то происходит пополнение склада;
    • Конъюнктура рынка - состояние спроса и предложения, покупательская способность потребителей, изменение курса валют, движение процентных ставок и т. д.
Механизмы:
    • Сотрудники - исполнители (работники склада, бухгалтер, персонал предприятия, выполняющий отгрузку комплектующих и учет их на складе и т. д.);
    • Складское оборудование - оборудования, которое обеспечивает работу аптеки в целом (компьютеры, специальные приборы и т. д.);
    • Менеджер - руководитель предприятия (исполнительный директор), отвечающий за выполнение заказов.
2.1.2. Диаграмма бизнес-процессов (IDEF0) AS-IS второго уровня
На рис. 2.2 показана декомпозиция контекстной диаграммы бизнес-процессов IDEF0 для более детального представления деятельности аптеки.

Рис. 2.2. Декомпозиция модели AS-IS в виде контекстной диаграммы «Деятельность аптеки».
Анализ модели и ее декомпозиции показал, что менеджер фирмы накапливает информацию о текущем состоянии склада по проданным лекарственным средствам. Чтобы не понести убытков в связи с неожиданным спросом на продукцию, менеджер для каждого вида лекарственных препаратов установил точку заказа – фиксированный уровень их запаса, при достижении которого необходимо сформировать следующий заказ на поставку. Этот уровень запаса менеджер устанавливает исходя из своего опыта и примерного состояния конъюнктуры рынка товаров. Подобный подход к принятию решения о пополнении склада содержит в себе большую долю риска, так как менеджер может принять интуитивно неверное решение и предприятие понесет убытки или не получит возможную прибыль.
2.2 Диаграмма бизнес-процессов (IDEF0) TO-BE
2.2.1. Диаграмма бизнес-процессов (IDEF0) TO-BE первого уровня
Представленная на рис. 2.3 модель ТО-BE демонстрирует, что при организации деятельности аптеки будут использоваться в качестве механизмов, реализующих рабочие процессы, следующие подсистемы:
    1. Модуль учета, который накапливает данные по продажам ЛС за прошедшие периоды времени.
    2. Модуль прогнозирования, который позволяет предсказать математическое ожидание спроса на каждый вид ЛС.
    3. Модуль поддержки принятия решения, который формирует различные комбинации и просчитывает затраты (потери) и прибыли, выдает рекомендацию по формированию склада (пополнению склада) с минимальными рисками потерь.

Рис. 2.3. Модель TO-BE в виде контекстной диаграммы «Деятельность аптеки».

2.2.2. Диаграмма бизнес-процессов (IDEF0) TO-BE второго уровня
На рис. 2.4 показана декомпозиция модели TO-BE контекстной диаграммы бизнес-процессов IDEF0 для более детального представления того, как изменится функционирование аптеки с использованием внедренных систем.

Рис. 2.4. Декомпозиция модели TO-BE в виде контекстной диаграммы 
«Деятельность аптеки».

2.3 Используемые методы и алгоритмы
Ниже приведены математические модели и алгоритмы [6] для формирования заказа и прогнозирования спроса на ЛС.
2.3.1. Формирование заказа на ЛС
Формирование заказа на ЛС производится с использованием следующих процедур:
    1. Формирование списка возможных событий и их вероятностей с использованием закона распределения вероятностей Пуассона. Вероятность событий вычисляется по формуле 1.1. Под событием понимается величина возможного спроса.
где =0, 1...n - количество возможных событий;
Xp() - возможные значения спроса любого товара на будущий период времени (следующий месяц);
 – вероятность появления спроса ;
 – период планирования, следующий месяц;
- математическое ожидание спроса для периода р (на следующий месяц).
    2. Формирование множества возможных действий по заказу каждого ЛС по формуле 1.2. Под действием понимается величина заказа ЛС.
Yp(1)=0,  Yp(2)= Yp(1)+ ha,  Yp(i)= Yp(i-1)+ ha, …, Yp(m)= Mp+ 100,
где i=0, 1...m - количество возможных действий;
Yp(i) - возможные значения действий для периода р;
ha - шаг для наращивания значений возможных действий;
 – период планирования, следующий месяц;
Обозначим через Aр(i) - действие «Заказать товар в количестве Yp(i) на p – ый период».
    3. Формирование списка возможных комбинаций Действие-Событие. Максимальное число таких комбинаций равно произведению n * m,
где n – количество возможных событий;
m – количество возможных действий.
    4. Расчет условных прибылей производится по формуле 1.3.
CP(Ap(j)Ep(i)) = E(j) * Sale_Price - ((A(j) * Wholesale_Price),
где i=0, 1...n - количество возможных событий;
j=0, 1...m - количество возможных действий;
A(j) – j-е действие;
E(i) – i-е событие; 
Wholesale_Price - оптовая цена покупки товара у поставщика;
Sale_Price = Wholesale_Price + Wholesale_Price * Percent - цена продажи товара; 
Percent – процент добавленной стоимости ЛС;
 – период планирования, следующий месяц;
CP(Ap(j)Ep(i)) – условная прибыль.
    5. Расчет взвешенных прибылей по формуле 1.4.

где i=0, 1...n - количество возможных событий;
j=0, 1...m - количество возможных действий;
 – -е действие;
 – -е событие; 
 – условная прибыль для события Ep(j) и действия Ap(i);
 – вероятность события Ep(j);
 взвешенная прибыль;
 – период планирования, следующий месяц.
    6. Расчет средних ожидаемых прибылей по формуле 1.5.
,
где =0, 1...n - количество возможных событий;
 – -е действие;
 – -е событие; 
– взвешенная прибыль для события  и действия ;
 - возможные значения спроса любого товара на будущий период;
 – период планирования, следующий месяц.

    7. Расчет максимального значения средних ожидаемых прибылей по формуле 1.6.

где =0, 1...m - количество возможных действий;
– средняя ожидаемая прибыль;
 – -е действие.
    8. Расчет условных потерь по формуле 1.7.
где i=0, 1...n - количество возможных событий;
j=0, 1...m - количество возможных действий;
 – -е действие;
 – -е событие; 
 – условная прибыль для события  и действия ;
 – условные потери.
    9. Расчет взвешенных потерь по формуле 1.8.
где i=0, 1...n - количество возможных событий;
j=0, 1...m - количество возможных действий;
 – -е действие;
 – -е событие; 
 – условные потери;
 – взвешенные потери;
 – вероятность события Ep(j).
    10. Расчет средних ожидаемых потерь по формуле 1.9.
где i=0, 1...n - количество возможных событий;
j=0, 1...m - количество возможных действий;
 – -е действие;
 – -е событие; 
 – возможные значения спроса любого товара на будущий период;
 – взвешенные потери.
    11. Расчет минимального значения средних ожидаемых потерь по формуле 1.10
где i=0, 1...m - количество возможных действий;
Ap(i) – i-е действие;
 – средние ожидаемые потери.
    12. Выдача рекомендации: оптимальным действием будет то, которое обеспечивает (соответствует) значения  и .
2.3.2. Прогнозирование математического ожидания величины спроса на ЛС
Прогнозирование математического ожидания величины спроса ЛС на следующий месяц будет проводиться на основе принципа самоорганизации, который состоит из следующих шагов [7]:
Шаг 1. Формирование множества алгоритмов, которые будут использоваться при конструировании самоорганизующегося прогноза. Под словом «алгоритм» понимается реализация какого-либо метода (модели) прогнозирования или сглаживания с заданным диапазоном значений его параметров. 
Шаг 2. Задание критерия (ошибки прогнозирования) отбора лучшего алгоритма для формирования прогноза. В качестве критерия отбора выбрана абсолютная ошибка прогнозирования на предыдущем шаге.
Шаг 3. Прогнозирование на обучающей выборке, где известны фактические значения наблюдаемого показателя, с применение всех алгоритмов из множества, сформированного на шаге 1.
Шаг 4. Оценивание качества прогноза, используя критерий, заданный на шаге 2. Алгоритм, показывающий наименьшее значение выбранного критерия, будет считаться лучшим. 
Шаг 5. Прогноз на будущий момент времени. В качестве результата (прогнозного значения) выводится величина, которая получена по алгоритму, выбранному на шаге 4.
Во множество алгоритмов были включены методы простого экспоненциального сглаживания (формула 1.11) [3] и двойного сглаживания Брауна (формулы 1.12–1.17) [3].


 


  = 

,
где i – момент времени, на который осуществляется прогноз,
n – количество наблюдаемых моментов времени,
 – прогноз на i-ый момент времени,   – фактическое значение на i-ый момент времени,
а – постоянная сглаживания, 
2.4 Диаграмма прецендентов
Диаграмма вариантов прецедентов [8] – это тип поведенческой диаграммы UML, который часто используется для анализа различных систем. С ее помощью возможно:
    • Идентифицировать функции и как с ними взаимодействуют роли – основное назначение диаграмм сценариев использования.
    • Представить системы на высоком уровне – Особенно полезно при представление руководителям или заинтересованным сторонам. Вы можете выделить роли, которые взаимодействуют с системой, и функциональные возможности, предоставляемые системой, не углубляясь во внутреннюю работу системы.
    • Идентифицировать внутренние и внешние факторы. Это может показаться простым, но в больших сложных проектах система может быть идентифицирована как внешняя роль в другом случае использования.
На рис. 2.5 приведена концептуальная модель разрабатываемой системы в виде диаграммы прецендентов. На ней показаны два актера и набор действий, характерных для каждого из них:
    • Администратор. Пользователь с этой ролью может управлять учетными записями других пользователей.
    • Менеджер. Пользователь с этой ролью может как управлять ЛС, так и получать рекомендации о заполнении склада, прогнозе спроса и просматривать отчеты по ЛС, спросу.
 
Рис. 2.5. Концептуальная модель системы.

2.5 Алгоритмическое проектирование. Диаграмма деятельности
2.5.1. Диаграмма деятельности для авторизации пользователей
На рис. 2.6 приведена диаграмма деятельности, отображающая процесс входа в систему пользователями.

Рис. 2.6. Вход в систему.

2.5.2. Диаграмма деятельности менеджера с системой
На рис. 2.7 приведена диаграмма деятельности, отображающая процесс взаимодействия менеджера с системой.

Рис. 2.7 Взаимодействие менеджера с системой.

2.5.3. Диаграмма деятельности для создания рекомендации
На рис. 2.8 приведена диаграмма деятельности, отображающая процесс создания рекомендации по формированию склада.

Рис. 2.8. Создание рекомендации по формированию склада.

2.5.4. Диаграмма деятельности для простого экспоненциального сглаживания
На рис. 2.9 приведена диаграмма деятельности, отображающая алгоритм простого экспоненциального сглаживания для прогнозирования спроса на ЛС.

Рис. 2.9. Алгоритм простого экспоненциального сглаживания.

2.5.5. Диаграмма деятельности для двойного сглаживания Брауна
На рис. 2.10 приведена диаграмма деятельности, отображающая алгоритм двойного сглаживания Брауна для прогнозирования спроса на ЛС.

Рис. 2.10. Алгоритм двойного сглаживания Брауна.

2.6 Организация структуры базы данных
На рис. 2.11 изображена ER модель, которая используется при высокоуровневом проектировании баз данных. Благодаря ей определяются таблицы и их поля, а также отношения, которые их связывают. Полное описание БД приведено в приложении I.

Рис. 2.11. Entity-Relationship модель рассматриваемой системы.
Описание каждой сущности представлено в таблице 2.1
 Таблица 2.1 – Назначение таблиц в БД
Название таблицы
Описание таблицы
users
Хранит персональные данные пользователей
roles
Хранит список доступных в системе ролей
medicines
Хранит данные о ЛС
medicineSales
Хранит историю продаж ЛС
medicineShippings
Хранит данные о поставках ЛС в аптеку
budgets
Хранит данные о бюджете организации

Продолжение таблицы 2.1
Название таблицы
Описание таблицы
categories
Хранит данные о категориях ЛС
recomendations
Хранит рекомендацию для формирования заявки на склад
administrativePurchases
Хранит данные об административных расходах
2.7 Диаграмма классов
Диаграмма классов позволяет спроектировать структуру всего приложения, используя объектно-ориентированный подход к моделированию. С её помощью определяются классы, из которых состоит система; методы и поля, принадлежащие им, а также отношения, существующие между ними. На рис. 2.12 приведена диаграмма классов для рассматриваемой системы. Полное описание классов приведено в приложении II.

Рис. 2.12. Диаграмма классов для рассматриваемой системы.

Описание классов представлено в таблице 2.2.
Таблица 2.2 – Описание классов рассматриваемой системы
Название класса
Описание класса
User
Управляет поведением пользователей
Role
Управляет поведением ролей пользователей
Recommendation
Управляет поведением рекомендаций для менеджера
Application
Управляет поведением всего приложения
AccountingType
Управляет поведением типов финансовых операций
Medicine
Управляет поведением ЛС
Sale
Управляет поведением продаж ЛС
Forecast
Управляет поведением прогноза спроса
Accounting
Управляет поведением прибыли и убытков аптеки
Forecast
Управляет поведением прогноза спроса
Accounting
Управляет поведением прибыли и убытков аптеки
2.8 Диаграмма последовательности
На рисунках 2.13–2.14 для рассматриваемой системы показана диаграмма последовательностей, позволяющая рассмотреть взаимодействие объектов во времени и отобразить их особенности приёма и передачи сообщений.

Рис. 2.13 Диаграмма последовательности для авторизации пользователей.

Рис. 2.14. Диаграмма последовательности для формирования заявки аптечного склада.
2.9 Диаграмма компонентов
Диаграмма компонентов – это статическая структурная диаграмма, которая показывает разбиение программной системы на структурные компоненты и связи (зависимости) между компонентами. В качестве физических компонентов могут выступать файлы, библиотеки, модули, исполняемые файлы, пакеты. С помощью диаграммы компонентов представляются инкапсулированные классы вместе с их интерфейсными оболочками, портами и внутренними структурами. На рис. 2.15 изображена диаграмма компонентов для рассматриваемой системы аптечного склада. На диаграмме представлены:
    • Подсистема Backend, отвечающая за взаимодействие с БД и обработкой запросов;
    • Подсистема Frontend, отвечающая за взаимодействие с пользователем и оправкой данных на Backend;
    • Компонент БД, отвечающий за хранение данных.

Рис. 2.15. Диаграмма компонентов для формирования заявки аптечного склада.
2.10 Диаграмма развертывания
Диаграмма развертывания покажет, какие аппаратные компоненты существуют, какие программные компоненты работают на каждом узле, и как различные элементы связаны.
На рис. 2.16 изображена диаграмма развертывания для рассматриваемой системы аптечного склада.

Рис. 2.16 Диаграмма развертывания для формирования заявки аптечного склада.
2.11 Выбор средств реализации
Для решения проблем, определённых ранее, будет создано веб-приложение, которое обладает рядом преимуществ:
    • Грамотная, но простая синхронизация между всеми гаджетами пользователя.
    • Веб приложение не требует дополнительных навыков владения компьютером: базовыми навыками работы с интернет-браузером обладает каждый владелец ПК. 

В качестве основного языка программирования (ЯП) для реализации ПО был выбран JavaScript [9] по нескольким причинам:
    • Является де-факто стандартом в сфере веб-приложений. 
    • Имеет большой набор модулей и библиотек, что позволяет работать гибко, подбирать готовые решения, тем самым экономя время разработки ПО и вывода его в использование.
В качестве средств разработки буду использованы:
    • Кроссплатформенная библиотека React для создания динамического 
пользовательского интерфейса.
    • Стандартные язык разметки HTML5 и язык описания внешнего вида 
документа CSS3.
    • Программная платформа Node.js для построения серверной части 
приложения, обеспечивающая высокую скорость обработки серверных 
запросов за счёт работы по принципу асинхронности.
    • База данных MongoDB, совместимая с веб приложениями и обеспечивающая высокую скорость выполнения запросов, критичную для приложений, оперирующих большим количеством данных.
ГЛАВА 3. РАЗРАБОТКА ДОКУМЕНТАЦИИ
3.1 Требования к программному и аппаратному обеспечению
Серверная часть:
    • Процессор: как минимум частотой 1 ГГц или SoC (System on a Chip, т.е. однокристальные системы) или выше;
    • Оперативная память: 4 ГБ (для 32-разрядных систем) или 8 ГБ (для 64-разрядных систем);
    • Дисковое пространство: 2 GB;
    • Операционная Windows, Linux, Mac OS;
    • СУБД Mongo DB;
    • JavaScript (стандарт EcmaScript6+);
    • Возможность доступа к localhost по HTTP протоколу.
    • Node.js 14+
Клиентская часть для ПК:
    • ОС: MS Windows 8/10, Mac OS X+, Ubuntu 16.04+;
    • Браузеры с поддержкой JavaScript’а (Chrome, Mozilla, Opera, Microsoft Edge и др.).
Клиентская часть для мобильных устройств:
    • OC: Android 6+, iOS 9+;
    • Браузеры для мобильных устройств с поддержкой JavaScript (Safari для iOS 9+, Chrome, Firefox).

3.2 Руководство программиста
3.2.1. Репозиторий
Репозиторий — это площадка, где хранится кодовая база проекта. В качестве репозитория была выбрана платформа GitHub, поскольку она является де-факто стандартом при разработке ПО. На рисунках 3.1-3.2 показана платформа GitHub, на которой было размещено 2 репозитория: репозиторий серверной (расположен по адресу  https://github.com/Alex-2kZharkov/pharmacy-stock-backend) и клиентской части (расположен по адресу https://github.com/Alex-2kZharkov/pharmacy-stock) приложения.

Рис. 3.1. Репозиторий клиентской части приложения.

Рис. 3.2. Репозиторий серверной части приложения.
3.2.2. История разработки
История разработки — это важнейшая составляющая любого проекта. Она достигается путем использования “коммитов”, то есть определенный участок кода, который был протестирован, и реализует функциональное требование фиксируется и отправляется в систему версий контроля. На рис. 3.3 показана история разработки проекта.


Рис. 3.3. История разработки клиентской части приложения.
3.2.3. База данных
База данных должна быть создана в соответствии с ER диаграммой, показанной на странице 34. Также БД может быть импортирована, используя “backup” – файлы, содержащий структуру БД и данные на момент создания бэкапа. На рис. 3.4 показан бэкап, который содержится в репозитории серверной части приложения. 

Рис. 3.4. Бэкапы базы данных.

Физическая структура БД показана на рис. 3.5. Далее необходимо импортировать бэкапа. Для этого необходимо открыть ПО для работы с БД MongoDB. В данном случае используется MongoDB Compass. После необходимо выбрать функцию импорта файла, выбрать файл с бэкапом, расположенный на компьютере разработчика, и нажать на кнопку «Import». На рис. 3.6 показан интерфейс завершения восстановления БД.

Рис. 3.5. Интерфейс базы данных

Рис. 3.6. Модальное окно завершения восстановления БД.

3.2.4. Структура проекта клиентской части
Модульная структура проект клиентской части приложения показана на рис. 3.7. Более детальное описание назначения каждого модуля приведено в таблице 3.1

Рис. 3.7. Модульная структура клиентской части приложения.

Таблица 3.1 – Назначение модулей клиентской части приложения
Название модуля
Назначение модуля
AdminPageWrapper
Компонент-обертка для страниц админ-панели
DateFilter
Интерактивные кнопки-фильтры записей в таблицах
DeleteButton
Кнопка удаления записи в таблице
DemandButton
Кнопка, открывающая график продаж ЛС
EditButton
Кнопка, открывающая окно редактирования записи
ErrorFallback
Надпись, отображаемая в случае возникновения ошибки
ItemsChart
График продаж ЛС, показываемый на главной странице админ-панели
RecommendationModal
Модальное окно с рекомендацией по закупке ЛС
RoleChip
Обертка для отображения роли пользователя на странице «Сотрудники» в админ-панели
Section
Контейнер для панели над таблицей с записями
Sidebar
Боковая панель для навигации между страницами
Toolbar
Компонент с полем поиска, кнопкой добавления записи и названием секции
constants
Постоянные величины
Administrative-purchases
Страница административных расходов
App
Корневой компонент приложения, с которого начинается отрисовка любой страницы
Category
Страница категорий ЛС
Login
Страница входа в систему
Medicine
Страница ЛС
Medicine-purchases
Страница ЛС на складе
Medicine-sale
Страница продаж ЛС
Overview
Главная страница в админ-панели
Recommendation
Страница с рекомендациями по закупке ЛС
Users
Страница сотрудников
Mock
Данные для запуска автоматических тестов
Services
Сервисы для выполнения HTTP запросов к серверу
Store
Сервис для хранения состояния приложения
Theme
Графические настройки страниц
Продолжение таблицы 3.1
Название модуля
Назначение модуля
Types
Универсальные интерфейсы, классы
Utils
Универсальные утилиты
Index.css
Файл с основными стилями приложения
Index.tsx
Корневой файл приложения
React-app-env.d.ts
Файл для загрузки конфигураций приложения
setupTests.tsx
Файл для установления конфигурации тестов
3.2.5. Структура проекта серверной части
Модульная структура проект серверной части приложения показана на рис. 3.8. Более детальное описание назначения каждого модуля приведено в таблице 3.2

Рис. 3.8. Модульная структура серверной части приложения.

Таблица 3.2 – Назначение модулей серверной части приложения
Название модуля
Назначение модуля
App
Корневой компонент приложения, с которого начинается сборка всего приложения
constants
Постоянные величины
database
Модуль подключения к БД
Administrative-purchases
REST API для административных расходов
Auth-module
REST API для аутентификации запросов пользователей
Budget
REST API для логики обработки бюджета
Categories
REST API для справочника категорий
Medicine-sales
REST API для истории продаж ЛС
Medicine-shippings
REST API для истории закупок ЛС
Medicines
REST API для справочника ЛС
Recommendations
REST API для справочника ЛС
Roles
REST API для справочника ролей в приложении
Users
REST API для справочника пользователей
Types
Универсальные интерфейсы, классы
Utils
Универсальные утилиты
Main.ts
Корневой файл приложения, который импортирует App и запускает приложение

3.3 Руководство пользователя
3.3.1. Форма входа
Открыв программу в первый раз, пользователь увидит форму для входа в систему: необходимо ввести логин (электронная почта) и пароль. Интерфейс формы показан на рис. 3.9.

Рис. 3.9. Форма входа в систему.
Стоит отметить, что пользователь будет уведомлен, если будет использован неправильный логин и/или пароль при входе в систему. На рис. 3.10 приведен интерфейс формы, демонстрирующий данный сценарий.

Рис. 3.10. Форма входа в систему с использованием неправильного логина и/или пароля.
3.3.2. Главная страница в админ-панели
При успешном входе в систему пользователь увидит главную страницу админ-панели. На ней присутствуют интерактивные кнопки-фильтры («Сегодня», «Вчера», «Неделя», «Месяц», «Квартал», «Год»), то есть нажав на кнопку, пользователь увидит данные только за указанный на кнопке период времени. На рис. 3.11 приведен интерфейс формы, демонстрирующий данный сценарий.

Рис. 3.11. Главная страница админ-панели.
Примечание: если пользователю присвоена роль «Администратор», то он увидит раздел «Сотрудники»; если пользователю присвоена роль «Менеджер», то он не увидит раздел «Сотрудники». На рисунках 3.12–3.13 приведены интерфейсы форм, демонстрирующие данные сценарии.

Рис. 3.12. Главная страница админ-панели для пользователя с ролью «Администратор».

Рис. 3.13. Главная страница админ-панели для пользователя с ролью «Менеджер».

3.3.3. Страница ЛС в админ-панели 
На рисунках 3.14–3.15 показана страница ЛС в админ-панель. Как и на главной странице, на данной странице имеются интерактивные кнопки-фильтры. Красная иконка в колонке «Остаток на складе» подсказывает, что на складе осталось меньше товара, чем точка заказа, устанавливаемая сотрудником аптеки.

Рис. 3.14. Страница ЛС.

Рис. 3.15. Страница ЛС. Продолжение.
Текстовые поле с надписью «Поиск по названию» предназначено для поиска ЛС по названию. На страницах «Справочник категорий товаров», «Товары на складе», «Продажи», «Сотрудники», «Административные расходы», «Рекомендации» данное текстовое работает аналогично, то есть оставляет в таблице результатов только те, которые связано с именем указанного ЛС. На рис. 3.16 приведен интерфейс формы, демонстрирующий данный сценарий.

Рис. 3.16. Поиск ЛС по названию.
Выпадающий список с надписью «Введите название категории» праздничен для поиска ЛС по названию категории. На рис. 3.17 приведен интерфейс формы, демонстрирующий данный сценарий.

Рис. 3.17. Поиск ЛС по названию категории.
Кликнув на иконку плюса, находящийся рядом с полем поиска по названию ЛС, пользователь увидит модальное окно для добавления нового товара. Стоит отметить, что, добавив товар, пользователь получит 0 единиц этого ЛС на складе. Чтобы увеличить число ЛС на складе, необходимо закупить товар. На рис. 3.18 приведен интерфейс формы, демонстрирующий данный сценарий.

Рис. 3.18. Добавление ЛС.
Существующий товар можно отредактировать, кликнув на иконку карандаша, напротив необходимого ЛС. После этого пользователь увидит модальное окно для редактирования ЛС. На рис. 3.19 приведен интерфейс формы, демонстрирующий данный сценарий.

Рис. 3.19. Редактирование ЛС.
Кликнув на иконку графиков, напротив необходимого ЛС пользователь получит рекомендацию по закупке данного ЛС на следующий месяц. Данная рекомендация информацию о числе ЛС, которое следует закупить, а также обоснование: почему необходимо закупить именно данное число ЛС. На рис. 3.20 приведен интерфейс формы, демонстрирующий данный сценарий.

Рис. 3.20. Рекомендация по пополнению склада.
Кликнув на иконку ценника, пользователь увидит модальное окно для закупки ЛС на склад. При закупке ЛС на сумму большую, чем доступно в бюджете, система оповещает пользователя о данном событии и блокирует кнопку «Сохранить», клик по которой завершает пополнение склада. На рисунках 3.21–3.22 приведены интерфейсы форм, демонстрирующие данный сценарий.

Рис. 3.21. Закупка товара.

Рис. 3.22. Форма закупки товара с заблокированным интерфейсом.
3.3.4. Страница категорий ЛС в админ-панели
Категории ЛС используются на странице «Справочник товаров». Пользователь может добавлять категорию, редактировать существую категорию, осуществлять поиск по названию категории. На рисунках 3.23–3.25 приведены интерфейсы форм, демонстрирующие данные сценарии.

Рис. 3.23. Страница категорий ЛС.

Рис. 3.24. Добавление категории.

Рис. 3.25. Редактирование категории.
3.3.5. Страница ЛС на складе в админ-панели
На странице «Товары» на складе отображается список товаров, которые были закуплены на склад. Если срок годности товара истекает менее, чем через 2 недели, то система покажет красная иконку, чтобы пользователь обратил внимание на данный товар и успел продать его до истечения срока годности. На рис. 3.26 приведен интерфейс формы, демонстрирующий данный сценарий.

Рис. 3.26. Страница ЛС на складе.
При нажатии на зеленую иконку тележки система покажет модальное окно, в котором пользователь может продать выбранное ЛС. Проданное количество ЛС отнимается от количества ЛС на складе, а на странице «Продажи» добавляется новая запись.
Стоит отметить, что если пользователь попытается продавать большее количество ЛС, чем количество ЛС на складе, то система оповещает пользователя о данном событии и блокирует кнопку «Сохранить», клик по которой завершает пополнение склада. На рисунках 3.27–3.28 приведен интерфейсы форм, демонстрирующих данный сценарий.

Рис. 3.27. Продажа товара.

Рис. 3.28. Заблокированный интерфейс продажи.
3.3.6. Страница продаж ЛС в админ-панели
На странице «Продажи» отображаются ЛС, которые были проданы в разделе «Товары на складе». На странице имеются интерактивные кнопки-фильтры, а также текстовое поле для поиска записи по названию ЛС. На рис. 3.29 приведен интерфейс формы, демонстрирующий данный сценарий.

Рис. 3.29. Страница проданных ЛС.
Напротив каждой записи о продаже ЛС имеется кнопка «Показать график продаж». Выбрав один из фильтров, например, «Квартал» и необходимое ЛС, пользователь увидит график продаж данного ЛС. На рис. 3.30 приведен интерфейс формы, демонстрирующий данный сценарий.

Рис. 3.30. График продаж выбранного ЛС.

3.3.7. Страница административных расходов в админ-панели
Страница административных расходов предназначена для фиксирования расходов, отличных от расходов на ЛС. На странице имеются интерактивные кнопки-фильтры, а также текстовое поле для поиска записи по описанию расхода. Административные расходы можно добавлять и редактировать. Для добавления нового расхода необходимо кликнуть на кнопку плюса, расположенную рядом с текстовым полем. Для редактирования данных записи необходимо кликнуть на кнопку карандаша напротив необходимой записи. На рисунках 3.31–3.33 приведены интерфейс форм, демонстрирующих данные сценарии.

Рис. 3.31. Страница административных расходов.

Рис. 3.32. Окно добавления новой записи в административные расходы.

Рис. 3.33. Редактирование существующего административного расхода.
3.3.8. Страница сотрудников в админ-панели
Данная страница доступна администраторам системы. Страница используется для управления учетными записями сотрудников. Стоит отметить, что администраторы не могут редактировать учетные записи других администраторов. На рис. 3.34 приведен интерфейс формы, демонстрирующий данный сценарий.

Рис 3.34. Страница сотрудников.
Для добавления нового сотрудника необходимо кликнуть на иконку плюса в верхней части экрана. Далее заполнить модальное окно данными о новом сотруднике. На рис. 3.35 приведен интерфейс формы, демонстрирующий данный сценарий.

Рис. 3.35. Добавление сотрудника.
Администратору также доступна возможность отредактировать данные о сотрудниках и удаления учетной записи сотрудника. Для редактирования данных сотрудника необходимо кликнуть на иконку карандаша напротив искомой записи и заполнить появившееся модальное окно новыми данными. Для удаления учетной записи необходимо кликнуть на красную иконку урны, нажать «Ок» в появившемся модальном окне. На рис. 3.36 приведен интерфейс формы, демонстрирующий данный сценарий.

Рис. 3.36. Редактирование сотрудника.
3.3.9. Страница рекомендаций в админ-панели
На данной странице отображается история рекомендаций, которые были созданы системой после того, как пользователь запросил рекомендацию по закупке ЛС на странице «Справочник товаров». Для просмотра полного текста рекомендации необходимо кликнуть на иконку глаза напротив искомой записи. На рисунках 3.37–3.38 приведены интерфейс форм, демонстрирующих данные сценарии.

Рис. 3.37. Страница рекомендаций по закупке ЛС.

Рис. 3.38. Полный текст рекомендации по закупке ЛС.

ГЛАВА 4. ЭКСПЕРИМЕНТАЛЬНЫЙ РАЗДЕЛ
4.1 План тестирования. 
4.1.1. Введение
Этот документ описывает план тестирования для рассматриваемой системы. Полная стратегия тестирования [10] программного обеспечения состоит из следующих типов испытаний и выполняется в следующем порядке:
    1. Юнит тестирование. Тестируются минимальные программные компоненты (при этом проверяется покрытие кода тестами). Параллельно проводится анализ кода: статический. Например, тестирование функции, которая реализует алгоритм Простого экспоненциального сглаживания.
    2. Тестирование интерфейсов пользователя: авто тесты, а также ручное usability тестирование. Например, отображаются ли список ЛС на экране пользователя.
    3. Тестирование интеграции. Тестируется программное обеспечение, чтобы гарантировать, что компоненты отображаются и взаимодействуют правильно. Например, взаимодействие поля для ввода названия искомого ЛС и списка с результатами поиска.
    4. Приемочные испытания. Проводятся приемочные испытания, чтобы гарантировать, что функциональные возможности ПО соответствуют требованиям к ПО, ожиданиям конечного пользователя и определения степени готовности продукта.
Приемочные испытания состоят из заключительного набора тестов, которые выполняются перед официальным запуском программной системы.
4.1.2. Область тестирования
Приемочные испытания состоят из:
    1. Тестирования серверной части системы.
    2. Тестирования клиентской части системы.

Цель тестирования состоит в том, чтобы определить, насколько хорошо внедряемое программное обеспечение соответствует функциональным требованиям, также идентифицировать обнаруженные проблемы и обеспечить их исправление. Тестирование также позволило бы собрать тестовые данные и тестовые результаты для дальнейшего регрессионного тестирования ПО в течение периода его поддержки.
Пожелания пользователей во время работы могут отличаться от их первоначальных; это не должно приниматься во внимание в течение тестирования ПО.
4.1.3. Стратегии тестирования
Главное в приемочном испытании — это продемонстрировать, что программное обеспечение и его инфраструктура устойчивы, и работают надежно. Все другие тестирующие действия должны быть закончены перед стартовой фазой приемочного испытания. Приемочное испытание ориентировано на тестирование программного обеспечения с точки зрения пользователя, чтобы проверить, как программное обеспечение используется день ото дня и как оно соответствует определенным требованиям качества.
4.1.4. Методы тестирования
Будут использованы следующие техники тестирования:
1. 	 Тестовые сценарии – сценарии вариантов использования (с предопределенным вводом и ожидаемыми выходными данными).
2. 	 Тестовые сценарии без данных - тестировщики выберут входные данные во время испытания.
3. 	 Тесты на несанкционированное использование – сценарии действий – попыток получить несанкционированный доступ к данным ПО.
4. 	 Проверка на удобство использования ПО - действия, чтобы оценить простоту системы в использовании.

4.2 Среда тестирования
Следующее программное обеспечение и аппаратная конфигурация должны быть доступны во время тестирования ПО:
    1. Серверная часть:
        ◦ Процессор: как минимум частотой 1 ГГц или SoC (System on a Chip, т. е. однокристальные системы) или выше;
        ◦ Оперативная память: 4 ГБ (для 32-разрядных систем) или 8 ГБ (для 64-разрядных систем);
        ◦ Дисковое пространство: 2 GB;
        ◦ Операционная Windows, Linux, Mac OS;
        ◦ СУБД Mongo DB;
        ◦ JavaScript (стандарт EcmaScript6+);
        ◦ Возможность доступа к localhost по HTTP протоколу.
        ◦ Node.js 14+
    2. Клиентская часть для ПК:
        ◦ ОС: MS Windows 8/10, Mac OS X+, Ubuntu 16.04+;
        ◦ Браузеры с поддержкой JavaScript’а (Chrome, Mozilla, Opera, Microsoft Edge и др.).
4.3 Сценарии тестирования. 
Нижеприведенные сценарии тестирования предназначены для проверки каждой программной функции. Часть этих сценариев повторно описывают сценарии вариантов использования. 
Каждый сценарий тестов состоит из следующего:
    1. Описание - эта часть представляет повторное описание документа по используемому сценарию. 
    2. Исходные данные - обычно это исходная конфигурация базы данных.
    3. Шаги тестирования — это действия, которые тестировщик должны выполнить в течение тестирования.
    4. Тестовые варианты – исходные данные и ожидаемая реакция ПО для каждого теста
    5. Ожидаемый результат работы программы — это фактическая реакция ПО для каждого теста.

4.3.1. Юнит тестирование
Сценарий 1. Функция getCurrentEntityActions()
Описание: функция должна вернуть объект с функциями для страницы пользователей
Исходные данные: название страницы
Шаги тестирования: вызвать функцию getCurrentEntityActions()
Тестовые варианты приведены в таблице 4.1
Таблица 4.1 - Тестовые варианты «Функция getCurrentEntityActions()»
Название страницы
фОжидаемый результат
User
Функция вернет объект с функциями обработки страницы пользователей

Функция вернет undefined
Ожидаемые результаты показаны на рис. 4.1.

Рис. 4.1. Результаты тестирования функции getCurrentEntityActions().
Сценарий 2. Функция countBySimpleExponentialSmoothing ()
Описание: функция должна вернуть ассоциативный массив для 0 < α <= 1
Исходные данные: массив фактов за предыдущие периоды времени
Шаги тестирования: вызвать функцию countBySimpleExponentialSmoothing ()
Тестовые варианты приведены в таблице 4.2

Таблица 4.2 - Тестовые варианты «Функция 
countBySimpleExponentialSmoothing ()».
Исходные данные
Ожидаемый результат
[3, 1, 2, 1, 4, 1]
Функция вернет массив из 10 элементов (альфа изменяется с шагом 0.1)
[3, 1, 2, 1, 4, 1]
Для  α = 1, прогноз будет равен 4
Ожидаемые результаты показаны на рис. 4.2.

Рис. 4.2. Результаты тестирования функции countBySimpleExponentialSmoothing ().
Сценарий 3. Функция countByBrownDoubleSmoothing ()
Описание: функция должна вернуть ассоциативный массив для 0 < α < 1.
Исходные данные: массив фактов за предыдущие периоды времени
Шаги тестирования: вызвать функцию countByBrownDoubleSmoothing ()
Тестовые варианты приведены в таблице 4.3
Таблица 4.3 - Тестовые варианты «Функция 
countByBrownDoubleSmoothing ()»
Исходные данные
Ожидаемый результат
[3, 1, 2, 1, 4, 1]
Функция вернет массив из 9 элементов (альфа изменяется с шагом 0.1)
[3, 1, 2, 1, 4, 1]
Для α = 0.5, прогноз будет равен 2.473


Ожидаемые результаты показаны на рис. 4.3.

Рис. 4.3. Результаты тестирования функции countByBrownDoubleSmoothing ().
4.3.2. Usability тестирование интерфейса клиентской части приложения
Результаты usability тестирования представлены в таблице 4.4.
Таблица 4.4 - Результаты usability тестирования 
интерфейса клиентской части
Номер
Вопрос
Оценка
1
Легкий поиск
4
2
Удобство и адекватность расширенного поиска
0
3
Возможность быстрого ознакомления со структурой сайта
5
4
Наличие рубрикатора
5
5
Выделение заголовков тем
5
6
Отображение времени новостей
3

Продолжение таблицы 4.4
Номер
Вопрос
Оценка
7
Наличие в новостях небольшого информационного описания содержания
4
8
Является ли качество используемой графики приемлемым?
4
9
Оптимизированы ли графические элементы для передачи по Интернету?
5
10
Используется ли анимация? Её не слишком много? Объем файлов приемлемый?
5
11
Цвета не раздражают?
4
12
Фон удачный?
4
13
Загрузка страниц происходит достаточно быстро?
5
14
Как работает сайт на мониторах высокого и низкого разрешения?
2
Средняя оценка равна 3,9 из 5 максимальных, что является приемлемой оценкой. Рекомендация: добавить возможность расширенного поиска в секции «Сотрудники», проработать более детально интерфейс для мониторов низкого разрешения.

4.3.3. Интеграционное тестирование клиентской части приложения
Сценарий 1. Компонент App
Описание: компонент должен выстроить клиентское приложение.
Исходные данные: логин и пароль пользователя
Шаги тестирования: запустить компонент App
Тестовые варианты приведены в таблице 4.5
Таблица 4.5. - Тестовые варианты «Компонент App»
Исходные данные
Ожидаемый результат




Login = Alexander.06.test.
zharkov@gmail.com
Password = test
Страница входа в систему будет отрисована

Главная страница админ-панели будет отрисована

Страница товаров админ-панели будет отрисована

Страница закупленных товаров админ-панели будет отрисована

Страница проданных товаров админ-панели будет отрисована

Страница категорий ЛС админ-панели будет отрисована

Страница сотрудников админ-панели будет отрисована

Страница рекомендаций админ-панели будет отрисована

Страница административных расходов админ-панели будет отрисована
Ожидаемые результаты показаны на рис. 4.4.

Рис. 4.4. Результаты тестирования компонента App.
4.3.4. Тестирование REST API
В серверной части приложения было разработано 29 роутов. В данном разделе будут показано 5 типовых запросов
Сценарий 1. Тестирование роута POST /api/auth/login
Описание: Данный роут возвращает аутентификационный токен для использования в дальнейших запросах.
Исходные данные: логин и пароль, существующие в БД
Ожидаемый результат:
    1. Код ответа сервера должен быть равен 200 (успешно).
    2. Формат данных ответа должен быть JSON.
    3. Роут должен вернуть аутентификационный токен и объект класса User.
Фактический результат представлен на рис. 4.5.

Рис. 4.5. Ответ сервера для роута POST /api/auth/login.

Сценарий 2. Тестирование роута GET /api/medicines?name=
Описание: Данный роут возвращает массив объектов ЛС.
Исходные данные: аутентификационный токен и опциональное название лекарства
Ожидаемый результат:
    1. Код ответа сервера должен быть равен 200 (успешно).
    2. Формат данных ответа должен быть JSON.
    3. Роут должен вернуть массив объектов класса Medicine
Фактический результат представлен на рис. 4.6.

Рис. 4.6. Ответ сервера для роута GET /api/medicines?name=.
Сценарий 3. Тестирование роута POST /api/medicines
Описание: Данный роут создает ЛС
Исходные данные: данные о новом ЛС
Ожидаемый результат:
    1. Код ответа сервера должен быть равен 201 (успешно создано).
    2. Новое ЛС добавлено в БД
Фактический результат представлен на рис. 4.7.

Рис. 4.7. Ответ сервера для роута POST /api/medicines.
Сценарий 4. Тестирование роута PUT /api/medicines/:id
Описание: Данный роут обновляет существующее ЛС
Исходные данные: данные о ЛС
Ожидаемый результат:
    1. Код ответа сервера должен быть равен 200 (успешно).
    2. Новое ЛС обновлено в БД
Фактический результат представлен на рис. 4.8.

Рис. 4.8. Ответ сервера для роута PUT /api/medicines/:id.

Сценарий 5. Тестирование роута DELETE /api/users/:id
Описание: Данный роут удаляет аккаунт пользователя
Исходные данные: id пользователя
Ожидаемый результат:
    1. Код ответа сервера должен быть равен 200 (успешно).
    2. Сообщение ответа с текстом «Пользователь удален»
Фактический результат представлен на рис. 4.9.

Рис. 4.9. Ответ сервера для роута PUT /api/medicines.

4.3.5. Метрики качества кода
Метрики качества кода были проверены при помощи IDE WebStorm. На рис. 4.10 представлены результаты статического анализа кода, которые показывают, что в коде присутствуют незначительные недочеты, например, объявлены переменные, которые не используются в программе. На рис. 4.11 приведены результаты компиляции кода. Из них видно, что программа успешно компилируется, что подтверждает готовность программы к эксплуатации.

Рис. 4.10. Результаты статического анализа кода программы.

Рис. 4.11. Результаты компиляции программы.
4.4 Результаты тестирования
В ходе работы над планом тестирования рассматриваемой системы были достигнуты следующие результаты:
    • Определены критерии тестирования;
    • Определены виды используемых тестов: 
        ◦ Юнит тесты;
        ◦ Usability тесты;
        ◦ Интеграционные тесты; 
        ◦ Тесты для REST API;
    • Определены сценарии тестов, необходимых к проверке.
Построенная система была протестирована с учетом приведенного выше плана тестирования. По его результатам был составлен отчет по тестированию. Тестирование проводилось как при помощи авто тестов, так и при помощи мануального (ручного) тестирования;
Прохождение всех тестов подтвердило устойчивость системы с точки зрения функциональных возможностей и ее готовности к использования конечными пользователями.
ЗАКЛЮЧЕНИЕ
В ходе работы над выпускной квалификационной работой были достигнуты следующие результаты:
    • Изучены особенности функционирования аптечных пунктов;
    • Выявлены проблемы, которые возникают в процессе работы аптеки;
    • Предложены решения выявленных проблем;
    • Сформулированы требования к программе;
    • Произведено проектирование архитектуры, алгоритмов, интерфейсов, БД разрабатываемой системы;
    • Определены средства для реализации ПО;
    • Разработано клиент-серверное приложение, которое:
    • Накапливает данные по продажам ЛС за прошедшие периоды времени;
    • Позволяет предсказать математическое ожидание спроса на каждый вид ЛС;
    • Формирует различные комбинации событий и действий и просчитывает затраты (потери) и прибыли каждого предлагаемого решения по заказу ЛС.
    • Выдает рекомендацию пользователю по формированию склада (пополнению склада) с минимальными рисками потерь.
    • Проведены различные виды тестирования разработанной системы (модульное, интеграционное, юзабилити, тестирование REST API), которые позволили убедиться в правильности ее работы;
Разработанная система внедрена в опытно-промышленную эксплуатацию в аптеку города Токмок в целях поддержки принятия эффективного управленческого решения по формированию запасов ЛС аптечного склада.

ЛИТЕРАТУРА
    1. Обзор аптечного бизнеса. Режим доступа: https://www.openbusiness.ru/biz/business/pharmacy.
    2. Юридические консультации, связанные с аптечным бизнесом. Режим доступа: https://law.kg/quest_cat_tags/otkrytie-apteki/
    3. Крокфорд Д. «JavaScript. Сильные стороны». 2012.
    4. Ситема SIMPLE. Режим доступа: http://scm-book.ru/book/export/html/71.
    5. Система STATISTICA. Режим доступа: http://statsoft.ru/solutions/tasks/forecast.
    6. Тен И. Г., Мусина И. Р., Хоменко Т. Н. - Разработка системы поддержки принятия многоэтапных управленческих решений в условиях неопределенности [Электронный ресурс]/ И.Г. Тен, И.Р. Мусина, Т.Н.Хоменко - Электрон. текстовые данные - Кыргызстан: Кыргызский государственный технический университет им. И.Раззакова - 2016г. №3 (39), часть 1- Режим доступа: https://kstu.kg/wpcontent/uploads/2016/11/Известия_39-часть-1.pdf
    7. Льюис К. Д. Методы прогнозирования экономических показателей. М.: Финансы и статистика, 1986. – 134c.
    8. Справочник по языку UML. Режим доступа: https://en.wikipedia.org/wiki/Unified_Modeling_Language
    9. Эллиот Э. «Программирование приложений на JavaScript». 2014
    10. Мусина И. Р. Методическое пособие «Тестирование программного обеспечения». Бишкек. 2017.
ГЛОССАРИЙ
JSON - текстовый формат обмена данными, основанный на JavaScript.
HTTP - протокол прикладного уровня передачи данных, изначально — в виде гипертекстовых документов в формате HTML, в настоящее время используется для передачи произвольных данных.
REST API - это набор правил того, как программисту организовать написание кода серверного приложения, чтобы все системы легко обменивались данными и приложение можно было масштабировать.
UML – язык графического описания для объектного моделирования в области разработки программного обеспечения.
Usability - исследование, выполняемое с целью определения, удобен ли некоторый искусственный объект (такой, как веб-страница, пользовательский интерфейс или устройство) для его предполагаемого применения.
Администратор – лицо, контролирующее деятельность сотрудников аптеки.
Аналог - объект (техническое решение) того же назначения, близкий по совокупности существенных признаков.
Архитектура системы – совокупность элементов и интерфейсов, их поведения и связей, являющаяся результатом проектирования.
База данных (БД) – совокупность данных, хранящихся в некотором информационном пространстве, размещенных по определенным принципам, законам, правилам для обеспечения ввода информации и выдачи необходимых сведений пользователю.
Бэкап — это предварительно созданная копия данных для восстановления в случае потери оригинальных данных.
Веб-приложение – клиент-серверное приложение, в котором клиент взаимодействует с веб-сервером при помощи браузера.
Веб-сервер - сервер, принимающий HTTP-запросы от клиентов, обычно веб-браузеров, и выдающий им HTTP-ответы, как правило, вместе с HTML-страницей, изображением, файлом, медиа-потоком или другими данными. 
Издержки производства -  затраты, связанные с производством товаров. В бухгалтерской и статистической отчетности отражаются в виде себестоимости. Включают в себя материальные затраты, расходы на оплату труда, проценты за кредиты 
Клиентское приложение – приложение, запускаемое в браузере клиента и выполняющее функции отображения текста, кнопок, изображений, анимаций и других элементов интерфейса. Состоит из HTMl, CSS и JavaScript. 
Лекарственное средство (ЛС) -  вещество или смесь веществ синтетического или природного происхождения в виде лекарственной формы (таблетки, капсулы, раствора, мази и т. п.), применяемые для профилактики, диагностики и лечения заболеваний.
Маршрутизация – процесс определения обработчика для запрашиваемой страницы.
Менеджер – сотрудник аптеки, с высшим медицинским образованием, отвечающий за формирование заявки на поставку.
Онлайн-сервис – сайт, предоставляющий какую-либо услугу. 
ПО – программа или множество программ, используемых для управления компьютером.
Продажа -  обмен товара или услуги на деньги, подтвержденный чеком продажи, актом выполненных работ, накладной передачи товара.
Работник – сотрудник аптечного пункта, имеющей среднее фармацевтическое или высшее медицинское образование.
Рендер – процесс обработки и отрисовки web-страницы браузером.
Роут – URL, к которому можно обратиться различными HTTP методами.
Серверное приложение – приложение, к которому обращается клиентское приложение и отвечающее за обработку запросов и обработку данных.
Система управления базой данных (СУБД) – комплекс программных средств, обеспечивающих централизованное хранение и выдачу данных из базы данных пользователю.
Спрос - зависимость между ценой и количеством товара, который покупатели могут и желают купить по строго определённой цене, в определённый промежуток времени.
Токен - компактное устройство, предназначенное для обеспечения информационной безопасности пользователя, также используется для идентификации его владельца, безопасного удалённого доступа к информационным ресурсам и т. д.
Точка заказа – фиксированный уровень запаса, при достижении которого необходимо сформировать следующий заказ на поставку.
Физическая модель базы данных – набор таблиц и столбцов, с определенными первичными и внешними ключами, необходимых для создания базы данных.
Фреймворк – набор инструментов и технологий, определяющих структуру приложения.
Язык программирования (ЯП) - формальный язык, предназначенный для записи компьютерных программ.

ПРИЛОЖЕНИЕ I
Таблица ПI.1 - Описание таблицы «budgets»
#
Имя
Тип
Атрибуты
Null
По умолчанию
Дополнительно
1
id
UUID

Нет
Нет
AUTO_GENERATED
2
createdAt
timestamp

Нет
new Date()

3
updatedAt
timestamp

Нет
new Date()

4
name
string

Нет
Нет

5
amount
number

Нет
Нет

Таблица ПI.2 - Описание таблицы «roles»
#
Имя
Тип
Атрибуты
Null
По умолчанию
Дополнительно
1
id
UUID

Нет
Нет
AUTO_GENERATED
2
createdAt
timestamp

Нет
new Date()

3
updatedAt
timestamp

Нет
new Date()

4
name
string

Нет
Нет

5
description
string

Нет
Нет

Таблица ПI.3 - Описание таблицы «recommendations»
#
Имя
Тип
Атрибуты
Null
По умолчанию
Дополнительно
1
id
UUID

Нет
Нет
AUTO_GENERATED
2
createdAt
timestamp

Нет
new Date()

3
updatedAt
timestamp

Нет
new Date()

4
medicineId
ObjectId

Нет
Нет

5
description
string

Нет
Нет


Таблица ПI.4 - Описание таблицы «users»
#
Имя
Тип
Атрибуты
Null
По умолчанию
Дополнительно
1
id
UUID

Нет
Нет
AUTO_GENERATED
2
createdAt
timestamp

Нет
new Date()

3
updatedAt
timestamp

Нет
new Date()

4
firstName
string

Нет
Нет

5
lastName
string

Нет
Нет

6
email
string

Нет
Нет

7
phone
string

Нет
Нет

8
password
string

Нет
Нет
SKIP_SELECTING
9
roleId
ObjectId

Нет
Нет

Таблица ПI.5 - Описание таблицы «medicines»
#
Имя
Тип
Атрибуты
Null
По умолчанию
Дополнительно
1
id
UUID

Нет
Нет
AUTO_GENERATED
2
createdAt
timestamp

Нет
new Date()

3
updatedAt
timestamp

Нет
new Date()

4
name
string

Нет
Нет

5
quantity
number

Нет
0

6
primaryAmount
number

Нет
Нет

7
finalAmount
number

Нет
Нет

8
percent
number

Нет
Нет

9
orderPoint
number

Нет
Нет


Таблица ПI.6 - Продолжение таблицы «medicines»
#
Имя
Тип
Атрибуты
Null
По умолчанию
Дополнительно
10
prognosis
number

Да
0

11
prognosisUpdatedAt
timestamp

Да
new Date()

12
categoryId
ObjectId

Нет
Нет

13
soldForMonth
number

Нет
0

Таблица ПI.7 - Описание таблицы «categories»
#
Имя
Тип
Атрибуты
Null
По умолчанию
Дополнительно
1
id
UUID

Нет
Нет
AUTO_GENERATED
2
createdAt
timestamp

Нет
new Date()

3
updatedAt
timestamp

Нет
new Date()

4
name
string

Нет
Нет

Таблица ПI.8 - Описание таблицы «administrativePurchases»
#
Имя
Тип
Атрибуты
Null
По умолчанию
Дополнительно
1
id
UUID

Нет
Нет
AUTO_GENERATED
2
createdAt
timestamp

Нет
new Date()

3
updatedAt
timestamp

Нет
new Date()

4
name
string

Нет
Нет

5
amount
number

Нет
Нет



Таблица ПI.9 - Описание таблицы «medicinesSales»
#
Имя
Тип
Атрибуты
Null
По умолчанию
Дополнительно
1
id
UUID

Нет
Нет
AUTO_GENERATED
2
createdAt
timestamp

Нет
new Date()

3
updatedAt
timestamp

Нет
new Date()

4
medicineId
ObjectId

Нет
Нет

5
amountPerUnit
number

Нет
Нет

6
totalAmount
number

Нет
Нет

7
quantity
number

Нет
Нет

Таблица ПI.10 - Описание таблицы «medicinesShippings»
#
Имя
Тип
Атрибуты
Null
По умолчанию
Дополнительно
1
id
UUID

Нет
Нет
AUTO_GENERATED
2
createdAt
timestamp

Нет
new Date()

3
updatedAt
timestamp

Нет
new Date()

4
medicineId
ObjectId

Нет
Нет

5
expirationDate
timestamp

Нет
Нет

6
totalAmount
number

Нет
Нет

7
quantity
number

Нет
Нет


ПРИЛОЖЕНИЕ II
Таблица ПII.1 - Описание класса «AdministrativePurchases»

Наименование
Описание
Атрибуты
id
Уникальный идентификатор объекта

createdAt
Дата создания

updatedAt
Дата обновления

name
Название расхода

amount
Сумма расхода

Методы
create()
Создание нового объекта

update()
Обновление существующего объекта

getAll()
Получить все объекты
Таблица ПII.2 - Описание класса «Role»

Наименование
Описание
Атрибуты
id
Уникальный идентификатор объекта

createdAt
Дата создания

updatedAt
Дата обновления

name
Название роли

description
Описание роли
Методы
getAll()
Получить все объекты
Таблица ПII.3 - Описание класса «AuthModule»

Наименование
Описание
Методы
login()
Осуществляет аутентификацию пользователя с использованием логина и пароля, а в дальнейшем - токена

Таблица ПII.4 - Описание класса «User»

Наименование
Описание
Атрибуты
id
Уникальный идентификатор объекта

createdAt
Дата создания

updatedAt
Дата обновления

firstName
Имя пользователя

lastName
Фамилия пользователя

email
Электронная почта пользователя

phone
Телефон пользователя

password
Пароль пользователя

role
Роль пользователя в системе


Методы
getOne()
Получить один объект

create()
Создать пользователя

update()
Обновить данные пользователя

delete()
Удалить пользователя

getAll()
Получить список всех пользователей
Таблица ПII.5 - Описание класса «MedicineSales»

Наименование
Описание
Атрибуты
id
Уникальный идентификатор объекта

createdAt
Дата создания

updatedAt
Дата обновления

medicine
Объект с данными о ЛС

amountPerUnit
Стоимость 1 единицы ЛС

totalAmount
Общая стоимость продажи


Методы
getProfit()
Получить прибыль от продажи

getDemand()
Получить данные о проданных ЛС для графика

create()
Добавить данные о проданном ЛС

getAll()
Получить список всех продажи

Таблица ПII.6 - Описание класса «Medicine»

Наименование
Описание
Атрибуты
id
Уникальный идентификатор объекта

createdAt
Дата создания

updatedAt
Дата обновления

name
Название ЛС

quantity
Количество ЛС на складе

description
Описание ЛС

amount
Стоимость всех ЛС


Методы
getOne()
Получить один объект ЛС

create()
Добавить ЛС

update()
Обновить ЛС

delete()
Удалить ЛС

getAll
Получить все объекты ЛС

createPrognosis()
Рассчитать спрос на ЛС
Таблица ПII.7 - Описание класса «Recommendation»

Наименование
Описание
Атрибуты
id
Уникальный идентификатор объекта

createdAt
Дата создания

updatedAt
Дата обновления

name
Описание рекомендации

medicine
Объект с данными о ЛС

Методы
create()
Добавить рекомендацию

getAll()
Получить все рекомендации

Таблица ПII.8 - Описание класса «Budget»

Наименование
Описание
Атрибуты
id
Уникальный идентификатор объекта

createdAt
Дата создания

updatedAt
Дата обновления

name
Описание показателя бюджета

amount
Сумма показателя бюджета

Методы
getOne()
Получить один объект с данными бюджета
Таблица ПII.9 - Описание класса «MedicineShippings»

Наименование
Описание
Атрибуты
id
Уникальный идентификатор объекта

createdAt
Дата создания

updatedAt
Дата обновления

medicine
Объект с данными о ЛС

amount
Стоимость покупки ЛС

expirationDate
Срок годности ЛС

quantity
Количество купленного ЛС

Методы
create()
Купить ЛС

getAll
Получить все объекты купленных ЛС
Таблица ПII.10 - Описание класса «Categories».

Наименование
Описание
Атрибуты
id
Уникальный идентификатор объекта

createdAt
Дата создания

updatedAt
Дата обновления

name
Название категории ЛС

Методы
create()
Добавить категорию

getAll
Получить все категории

Таблица ПII.11 - Описание класса «Application»

Наименование
Описание
Атрибуты
user
Объект класса User

role
Объект класса Role

medicine
Объект класса Medicine

medicineSale
Объект класса MedicineSale

budget
Объект класса Budget

administrativePurchase
Объект класса AdministrativePurchase

authModule
Объект класса AuthModule

category
Объект класса Category

medicineShipping
Объект класса MedicineShipping

recommendation
Объект класса Recommendation

Методы
run()
Запускает приложение

ПРИЛОЖЕНИЕ III
Листинг серверной части программы
Файл medicine.service.ts
import { Injectable, NotFoundException } from '@nestjs/common';
import { UpdateMedicineDto } from './dto/update-medicine.dto';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Medicine, MedicineDocument } from './entities/medicine.schema';
import { Base } from '../../database/Base.schema';
import { sub } from 'date-fns';
import {
  countByBrownDoubleSmoothing,
  countBySimpleExponentialSmoothing,
  countLosses,
  countLossesByAction,
  countMaxConditionalProfitsByEvent,
  countProfit,
  getMaxExpectedMonetaryValue,
  getMinExpectedLosses,
  getMinimumByTolerance,
} from '../../utils/algorithm.utils';
import { countProbabilityUsingPoissonDistribution } from '../../utils/algorithm.utils';
import {
  MedicineSale,
  MedicineSaleDocument,
} from '../medicine-sales/entities/medicine-sales.schema';
import {
  Recommendation,
  RecommendationDocument,
} from '../recommendations/entities/recommendation.schema';
@Injectable()
export class MedicinesService {
  constructor(
    @InjectModel(Medicine.name) private medicineModel: Model<MedicineDocument>,
    @InjectModel(Recommendation.name)
    private recommendationModel: Model<RecommendationDocument>,
    @InjectModel(MedicineSale.name)
    private medicineSaleModel: Model<MedicineSaleDocument>,
  ) {}
  async create(createMedicineDto: Medicine) {
    return await this.medicineModel.create({
      ...createMedicineDto,
      quantity: createMedicineDto.quantity || 0,
      orderPoint: createMedicineDto.orderPoint || 0,
      _id: undefined,
    });
  }
  async findAll(
    dateFrom: Date | null,
    name: string,
    categoryFilter: string,
  ): Promise<MedicineDocument[]> {
    const regex = new RegExp(name, 'i'); // i for case insensitive
    const options = dateFrom
      ? {
          updatedAt: {
            $gte: dateFrom,
          },
        }
      : undefined;
    const results = await this.medicineModel
      .find(options)
      .sort({ updatedAt: -1 })
      .populate('category')
      .exec();
    return results.filter((value: MedicineDocument) => {
      if (name) {
        return (value as Medicine).name.match(regex);
      }
      if (categoryFilter) {
        return (value as Medicine).category?.name?.match(categoryFilter);
      }
      return value;
    });
  }
  findOne(id: number) {
    return `This action returns a #${id} medicine`;
  }
  async update(id: string, updateMedicineDto: UpdateMedicineDto) {
    try {
      const medicine = await this.medicineModel.findById(id);
      await medicine.update({ $set: { ...updateMedicineDto } }).exec();
    } catch {
      throw new NotFoundException('Товар не найден');
    }
  }
  remove(id: number) {
    return `This action removes a #${id} medicine`;
  }
  getRealDemandByMonths(medicineSales: MedicineSaleDocument[]): number[] {
    const quantitiesByMonths = medicineSales.reduce(
      (accum, { createdAt, quantity }: MedicineSale & Base) => {
        const monthNumber = new Date(createdAt).getMonth();
        const existedQuantity: number = accum[monthNumber];
        accum[monthNumber] = existedQuantity
          ? existedQuantity + quantity
          : quantity;
        return accum;
      },
      {},
    );
    return medicineSales.reduce((accum, medicineSale: MedicineSale & Base) => {
      const monthIndex = new Date(medicineSale.createdAt).getMonth();
      const quantity = quantitiesByMonths[monthIndex];
      if (quantity) {
        accum.push(quantitiesByMonths[monthIndex]);
        delete quantitiesByMonths[monthIndex];
      }
      return accum;
    }, []);
  }
  async countPrognosis(id: string) {
    const medicine: Medicine = await this.medicineModel.findById(id).lean();
    const medicineSales: MedicineSale[] = await this.medicineSaleModel
      .find({
        medicine,
        createdAt: {
          $gte: sub(new Date(), { months: 6 }),
          $lte: new Date(),
        },
      })
      .sort({ createdAt: 1 })
      .lean();
    const realDemands: number[] = this.getRealDemandByMonths(medicineSales);
    const simpleExponentialSmoothingPrognosis =
      countBySimpleExponentialSmoothing(realDemands);
    const brownDoubleSmoothingPrognosis =
      countByBrownDoubleSmoothing(realDemands);
    const orderPoint: number = getMinimumByTolerance(
      realDemands[realDemands.length - 2],
      ...simpleExponentialSmoothingPrognosis,
      ...brownDoubleSmoothingPrognosis,
    );
    const events = countProbabilityUsingPoissonDistribution(orderPoint);
    const expectedMonetaryValues = countProfit(
      events,
      medicine.primaryAmount,
      medicine.finalAmount,
    );
    const maxExpectedProfit = getMaxExpectedMonetaryValue(
      expectedMonetaryValues,
    );
    const losses = countLosses(
      events,
      medicine.primaryAmount,
      medicine.finalAmount,
    );
    const maxConditionalProfits = countMaxConditionalProfitsByEvent(losses);
    const expectedLosses = countLossesByAction(
      events,
      medicine.primaryAmount,
      medicine.finalAmount,
      maxConditionalProfits,
    );
    const minExpectedLose = getMinExpectedLosses(expectedLosses);
    if (maxExpectedProfit.x === minExpectedLose.x) {
      medicine.prognosis = orderPoint;
      medicine.prognosisUpdatedAt = new Date();
      await this.medicineModel.updateOne(
        { _id: id },
        {
          $set: {
            prognosis: orderPoint,
            prognosisUpdatedAt: new Date(),
          },
        },
      );
      console.log(maxExpectedProfit);
      console.log(minExpectedLose);
      const recommendationDescription = `Менеджеру рекомендуется заказать товар "${
        medicine.name
      }" в количестве ${orderPoint} ед., поскольку 
          выбор данного решения позволит получить максимальную среднюю ожидаемую прибыль (${maxExpectedProfit.weightedProfit.toFixed(
            2,
          )})
          и обеспечит минимальное среднее ожидаемое денежное значение потери (${minExpectedLose.weightedLoss.toFixed(
            2,
          )}).`;
      return await this.recommendationModel.create({
        medicine,
        description: recommendationDescription,
      });
    }
    return {
      message: 'Не удалось вычислить оптимальное количество товаров к заказу.',
    };
  }
}
Файл algorithm.utils.ts
import {
  convertToNumber,
  convertToNumberWithRounding,
} from './conversion.utils';
import { APPLICABLE_PROBABILITY } from '../constants/algorithm.constants';
import {
  ConditionalProfit,
  ConditionalProfitByEvent,
  PoissonResult,
  WeightedLoss,
  WeightedProfit,
} from '../types/calculations.types';
// eslint-disable-next-line @typescript-eslint/no-var-requires
const pmf = require('@stdlib/stats-base-dists-poisson-pmf');
export const countBySimpleExponentialSmoothing = (
  factNumbers: number[],
): number[] => {
  // eslint-disable-next-line prefer-const
  let [prevFact, ...restFacts] = factNumbers;
  // для всех 0 < альфа <= 1
  const resultObject = {
    '0.1': prevFact,
    '0.2': prevFact,
    '0.3': prevFact,
    '0.4': prevFact,
    '0.5': prevFact,
    '0.6': prevFact,
    '0.7': prevFact,
    '0.8': prevFact,
    '0.9': prevFact,
    '1': prevFact,
  };
  // метод простого сглаживания
  for (const fact of restFacts) {
    for (let j = 0.1; j <= 1; j += 0.1) {
      const truncIndex = convertToNumber(j, 1);
      const truncPrognosis = convertToNumber(
        resultObject[truncIndex] as number,
        4,
      );
      resultObject[truncIndex] = convertToNumber(
        prevFact * truncIndex + (1 - truncIndex) * truncPrognosis,
        4,
      );
    }
    prevFact = fact;
  }
  return Object.values(resultObject);
};
export const countByBrownDoubleSmoothing = (
  factNumbers: number[],
): number[] => {
  // метод двойного экспоненциального сглаживания
  // eslint-disable-next-line prefer-const
  let [prevFact, ...restFacts] = factNumbers;
  let S1 = prevFact,
    S2 = prevFact,
    a0 = prevFact,
    a1 = 0,
    y;
  // для всех 0 < альфа <= 0.9
  const tempObject: {
    [x: string]: {
      S1: number;
      S2: number;
      value?: number;
    };
  } = {
    '0.1': {
      S1: prevFact,
      S2: prevFact,
    },
    '0.2': {
      S1: prevFact,
      S2: prevFact,
    },
    '0.3': {
      S1: prevFact,
      S2: prevFact,
    },
    '0.4': {
      S1: prevFact,
      S2: prevFact,
    },
    '0.5': {
      S1: prevFact,
      S2: prevFact,
    },
    '0.6': {
      S1: prevFact,
      S2: prevFact,
    },
    '0.7': {
      S1: prevFact,
      S2: prevFact,
    },
    '0.8': {
      S1: prevFact,
      S2: prevFact,
    },
    '0.9': {
      S1: prevFact,
      S2: prevFact,
    },
  };
  // метод простого сглаживания
  for (const fact of restFacts.slice(0, -1)) {
    for (let j = 0.1; j <= 0.9; j += 0.1) {
      const truncIndex = Number(j.toFixed(1));
      S1 = convertToNumberWithRounding(
        truncIndex * fact + (1 - truncIndex) * tempObject[truncIndex].S1,
      );
      S2 = convertToNumberWithRounding(
        truncIndex * S1 + (1 - truncIndex) * tempObject[truncIndex].S2,
      );
      a0 = convertToNumberWithRounding(2 * S1 - S2);
      a1 = convertToNumberWithRounding(
        (truncIndex / (1 - truncIndex)) * (S1 - S2),
      );
      y = convertToNumberWithRounding(a0 + a1); // т.к. 1 период планирования
      tempObject[truncIndex].value = y;
      tempObject[truncIndex].S1 = S1;
      tempObject[truncIndex].S2 = S2;
    }
    prevFact = fact;
  }
  return Object.values(tempObject).map((property) => property.value);
};
// алгоритм поиска минимального значения (минимум ищется по абсолютной разнице факта и прогноза)
export const getMinimumByTolerance = (
  fact: number,
  ...forecasts: number[]
): number => {
  let minObj = {
    tolerance: Math.abs(fact - forecasts[0]),
    prognosis: forecasts[0],
  };
  for (let i = 1; i < forecasts.length; i++) {
    const tolerance = Math.abs(fact - forecasts[i]);
    if (minObj.tolerance > tolerance) {
      minObj = {
        tolerance,
        prognosis: forecasts[i],
      };
    }
  }
  return minObj.prognosis;
};
export const countProbabilityUsingPoissonDistribution = (
  prognosis: number,
): PoissonResult[] => {
  // расчет вероятностей при помощи закона распределения Пуассона из проверенной сторонней библиотеки
  const resultObject = [];
  for (let x = 0; x <= 10 + prognosis; x++) {
    const probability = convertToNumberWithRounding(pmf(x, prognosis), 1000);
    if (probability > APPLICABLE_PROBABILITY) {
      resultObject.push({
        prognosis,
        x,
        probability,
      });
    }
  }
  return resultObject;
};

Листинг клиентской части программы
Файл Medicines.tsx
import { MouseEvent, useEffect, useState } from "react";
import {
  Autocomplete,
  Box,
  CircularProgress,
  Stack,
  Typography,
  TextField,
} from "@mui/material";
import { DataGrid } from "@mui/x-data-grid";
import { debounce } from "lodash";
import { AdminPageWrapper } from "../../components/AdminPageWrapper";
import { DateFilter } from "../../components/DateFilter";
import { RecommendationModal } from "../../components/RecommendationModal";
import { DATE_PERIODS } from "../../constants/filter.constants";
import { DEBOUNCE_TIME } from "../../constants/size.constants";
import { useGetCategoriesQuery } from "../../services/api/category.api";
import {
  useLazyBuyMedicineQuery,
  useLazyCalculatePrognosisQuery,
  useLazyCreateMedicineQuery,
  useLazyGetMedicinesQuery,
  useLazyUpdateMedicineQuery,
} from "../../services/api/medicine.api";
import { useGetBudgetQuery } from "../../services/api/overview.api";
import { useAppDispatch, useAppSelector } from "../../store/hooks";
import { ACCENT, WHITE } from "../../theme/colors/colors.constants";
import { PagesTypes } from "../../types/common/pages.types";
import { CategoryDto } from "../../types/dto/Category.dto";
import { MedicineDto } from "../../types/dto/Medicine.dto";
import { selectCurrentSearchValue, setCurrentPage } from "../app/appSlice";
import { BuyMedicineDialog } from "./components/BuyMedicineDilalog";
import { BuyMedicineDialogTypes } from "./components/BuyMedicineDilalog/BuyMedicineDialog.types";
import { MedicineDialog } from "./components/MedicineDialog";
import { MEDICINE_TABLE_COLUMNS } from "./Medicines.constants";
import { useStyles } from "./Medicines.styles";
import {
  selectCurrentEditableMedicine,
  selectIsBuyMedicineDialogOpen,
  selectIsCalculatePrognosisDialogOpen,
  selectIsCreateMedicineDialogOpen,
  selectIsEditMedicineDialogOpen,
  setCurrentEditableMedicine,
  setIsBuyMedicineDialogOpen,
  setIsCalculatePrognosisDialogOpen,
  setIsCreateMedicineDialogOpen,
  setIsEditMedicineDialogOpen,
} from "./medicineSlice";
export const Medicines = () => {
  const classes = useStyles();
  const dispatch = useAppDispatch();
  const currentEditableMedicine = useAppSelector(selectCurrentEditableMedicine);
  const isCreateMedicineDialogOpen = useAppSelector(
    selectIsCreateMedicineDialogOpen
  );
  const isEditOrderPointDialogOpened = useAppSelector(
    selectIsEditMedicineDialogOpen
  );
  const isCalculatePrognosisDialogOpen = useAppSelector(
    selectIsCalculatePrognosisDialogOpen
  );
  const isBuyMedicineDialogOpen = useAppSelector(selectIsBuyMedicineDialogOpen);
  const currentSearchValue = useAppSelector(selectCurrentSearchValue);
  const { data: budget, refetch } = useGetBudgetQuery();
  const [getMedicines, { data: medicineList }] = useLazyGetMedicinesQuery();
  const [createMedicine, { isFetching: isCreationExecuting }] =
    useLazyCreateMedicineQuery();
  const [updateMedicine, { isFetching: isUpdateExecuting }] =
    useLazyUpdateMedicineQuery();
  const [calculatePrognosis, { data: prognosisData }] =
    useLazyCalculatePrognosisQuery();
  const [buyMedicine, { isFetching: isBuyingExecuting }] =
    useLazyBuyMedicineQuery();
  const { data: categoriesList } = useGetCategoriesQuery({
    dateFilter: "",
    name: "",
  });
  const [periodName, setPeriodName] = useState("");
  const [inputValue, setInputValue] = useState("");
  const handleCalculatePrognosisDialogClose = () =>
    dispatch(setIsCalculatePrognosisDialogOpen(false));
  const handleCreateMedicineDialogClose = () =>
    dispatch(setIsCreateMedicineDialogOpen(false));
  const handleCreateMedicineDialogConfirm = (payload: Partial<MedicineDto>) => {
    createMedicine(payload);
    handleCreateMedicineDialogClose();
  };
  const handleEditMedicineDialogClose = () =>
    dispatch(setIsEditMedicineDialogOpen(false));
  const handleEditMedicineDialogConfirm = (payload: Partial<MedicineDto>) => {
    updateMedicine(payload);
    dispatch(setCurrentEditableMedicine(undefined));
    handleEditMedicineDialogClose();
  };
  const handleBuyMedicineDialogClose = () =>
    dispatch(setIsBuyMedicineDialogOpen(false));
  const handleBuyMedicineDialogConfirm = (payload: BuyMedicineDialogTypes) => {
    buyMedicine(payload);
    dispatch(setCurrentEditableMedicine(undefined));
    handleBuyMedicineDialogClose();
  };
  const handleChange = (
    event: MouseEvent<HTMLElement>,
    newPeriodName: string
  ) => {
    setPeriodName(newPeriodName);
  };
  useEffect(() => {
    dispatch(setCurrentPage(PagesTypes.ITEMS_PAGE));
  }, [dispatch]);
  useEffect(() => {
    if (currentEditableMedicine?._id && isCalculatePrognosisDialogOpen) {
      calculatePrognosis(currentEditableMedicine?._id);
    }
  }, [
    calculatePrognosis,
    currentEditableMedicine?._id,
    isCalculatePrognosisDialogOpen,
  ]);
  useEffect(() => {
    const debouncedRequest = debounce(getMedicines, DEBOUNCE_TIME);
    debouncedRequest({
      dateFilter: DATE_PERIODS[periodName]?.toISOString(),
      name: currentSearchValue,
      categoryFilter: inputValue,
    });
    refetch();
  }, [
    getMedicines,
    isUpdateExecuting,
    isCreationExecuting,
    isCalculatePrognosisDialogOpen,
    isBuyingExecuting,
    prognosisData?.description,
    currentSearchValue,
    refetch,
    periodName,
    inputValue,
  ]);
  return (
    <>
      <AdminPageWrapper sectionTitle="Справочник товаров">
        <Stack
          direction="row"
          justifyContent="space-between"
          alignItems="center"
          className={classes.dateFilterContainer}
        >
          <DateFilter value={periodName} onChange={handleChange} />
          <Autocomplete
            disablePortal
            getOptionLabel={(option: CategoryDto) => option.name}
            id="combo-box-demo"
            options={categoriesList ?? []}
            sx={{
              width: 400,
              marginLeft: -5,
              backgroundColor: WHITE,
            }}
            renderInput={(params) => (
              <TextField {...params} label="Введите название категории" />
            )}
            inputValue={inputValue}
            onInputChange={(_, newInputValue) => {
              setInputValue(newInputValue);
            }}
          />
          <Typography variant="h6">
            Всего записей: {medicineList?.length ?? 0}
          </Typography>
        </Stack>
        {!medicineList ? (
          <Stack
            sx={{ marginTop: 2 }}
            direction="row"
            alignItems="center"
            justifyContent="center"
          >
            <CircularProgress
              style={{ marginTop: 150, color: ACCENT }}
              size={150}
            />
          </Stack>
        ) : (
          <Box className={classes.dataGridContainer}>
            <DataGrid
              className={classes.dataGrid}
              columns={MEDICINE_TABLE_COLUMNS}
              disableSelectionOnClick
              rows={medicineList ?? []}
              disableColumnMenu={true}
              getRowId={(row) => row._id}
              components={{
                // eslint-disable-next-line react/no-multi-comp
                NoRowsOverlay: () => (
                  <Stack
                    height="100%"
                    alignItems="center"
                    justifyContent="center"
                  >
                    Нет данных
                  </Stack>
                ),
              }}
            />
          </Box>
        )}
      </AdminPageWrapper>
      <RecommendationModal
        isOpen={isCalculatePrognosisDialogOpen}
        onClose={handleCalculatePrognosisDialogClose}
        message={prognosisData?.description}
      />
      <MedicineDialog
        isOpen={isCreateMedicineDialogOpen}
        onClose={handleCreateMedicineDialogClose}
        confirm={handleCreateMedicineDialogConfirm}
        categories={categoriesList}
      />
      <MedicineDialog
        isOpen={isEditOrderPointDialogOpened}
        onClose={handleEditMedicineDialogClose}
        confirm={handleEditMedicineDialogConfirm}
        medicine={currentEditableMedicine}
        categories={categoriesList}
      />
      <BuyMedicineDialog
        isOpen={isBuyMedicineDialogOpen}
        onClose={handleBuyMedicineDialogClose}
        confirm={handleBuyMedicineDialogConfirm}
        medicine={currentEditableMedicine}
        budgetAmount={budget?.amount ?? 0}
      />
    </>
  );
};